Collecting frontend code...
=========================

===== front-end/app.js =====
// front-end/app.js
import express           from 'express';
import session           from 'express-session';
import cookieParser      from 'cookie-parser'; // Add cookie parser import
import path              from 'path';
import { fileURLToPath } from 'url';
import morgan            from 'morgan';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const app       = express();

// ─────────────────────────────────────────────────────────────────────────────
// 0)  API base-URL resolution
// ─────────────────────────────────────────────────────────────────────────────
const API_BASE        =
  process.env.GO_API_URL       ||
  process.env.ORCHESTRATOR_URL ||
  'http://orchestrator:8080';

const GOOGLE_AUTH_URL =
  process.env.GOOGLE_AUTH_URL ||
  'http://google_auth_service:8086';    // Use Docker service name

// ─────────────────────────────────────────────────────────────────────────────
// 1)  3rd-party middleware
// ─────────────────────────────────────────────────────────────────────────────
app.use(morgan('dev'));
app.use(cookieParser()); // Add cookie parser middleware

// ─────────────────────────────────────────────────────────────────────────────
// 2)  Static assets
// ─────────────────────────────────────────────────────────────────────────────
app.use(express.static(path.join(__dirname, 'public')));

// ─────────────────────────────────────────────────────────────────────────────
// 3)  Body-parsers
// ─────────────────────────────────────────────────────────────────────────────
app.use(express.urlencoded({ extended: false }));
app.use(express.json());

// ─────────────────────────────────────────────────────────────────────────────
// 4)  Sessions & locals
// ─────────────────────────────────────────────────────────────────────────────
app.use(session({
  secret           : 'change-this-secret',
  resave           : false,
  saveUninitialized: true,
}));
app.use((req, res, next) => {
  res.locals.user       = req.session.user || null;
  res.locals.currentUrl = req.originalUrl;
  res.locals.API_BASE   = API_BASE;
  next();
});

// ─────────────────────────────────────────────────────────────────────────────
// 5)  EJS templating
// ─────────────────────────────────────────────────────────────────────────────
app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));

// ─────────────────────────────────────────────────────────────────────────────
// 6)  GOOGLE OAUTH PROXY
//    Forward front-end `/auth/google/...` to your google_auth_service.
// ─────────────────────────────────────────────────────────────────────────────
app.get('/auth/google/login', (req, res) => {
  const role = req.query.role || 'institution_representative';
  // For Docker, we need to redirect to the external URL
  const externalGoogleAuthUrl = process.env.GOOGLE_AUTH_EXTERNAL_URL || 'http://localhost:8086';
  res.redirect(`${externalGoogleAuthUrl}/auth/google/login?role=${role}`);
});

// Handle successful Google login callback
app.get('/auth/google/callback', (req, res) => {
  console.log('Google callback received:', req.query);
  
  // Check if we have a JWT cookie
  const token = req.cookies.token;
  const role = req.query.role || 'institution_representative';
  const email = req.query.email;
  
  if (token && req.query.google_login === 'success') {
    // Set session for Google user
    req.session.user = {
      username: email || 'google_user',
      role: role
    };
    
    console.log('Set session user:', req.session.user);
    
    // Redirect based on role
    let redirectPath = '/';
    switch (role) {
      case 'student':
        redirectPath = '/student';
        break;
      case 'instructor':
        redirectPath = '/instructor';
        break;
      case 'institution_representative':
        redirectPath = '/institution';
        break;
      default:
        redirectPath = '/';
    }
    
    res.redirect(redirectPath);
  } else {
    console.log('Google login failed - no token or success flag');
    res.redirect('/login?error=google_login_failed');
  }
});

// ─────────────────────────────────────────────────────────────────────────────
// 7)  Auth helper
// ─────────────────────────────────────────────────────────────────────────────
function auth(role) {
  return (req, res, next) => {
    if (!req.session.user) return res.redirect('/login');
    if (role) {
      if (role === 'institution') {
        if (!['institution','representative','institution_representative']
              .includes(req.session.user.role)) {
          return res.redirect(`/${req.session.user.role}`);
        }
      } else if (req.session.user.role !== role) {
        return res.redirect(`/${req.session.user.role}`);
      }
    }
    next();
  };
}

// ─────────────────────────────────────────────────────────────────────────────
// 8)  Dummy users (dev only)
// ─────────────────────────────────────────────────────────────────────────────
const users = { alice: 'student', bob: 'instructor', iris: 'institution' };

// ─────────────────────────────────────────────────────────────────────────────
// 9)  UI routes
// ─────────────────────────────────────────────────────────────────────────────

// Home
app.get('/', (req, res) => {
  if (!req.session.user) return res.redirect('/login');
  res.redirect(`/${req.session.user.role}`);
});

// Signup / Login
app.get('/signup', (_, res) =>
  res.render('signup', { title: 'Sign Up', user: null })
);

app.get('/login', (_, res) =>
  res.render('login', { title: 'Log in', error: null, user: null })
);

// CLASSIC form POST – creates session
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  try {
    const response = await fetch(`${API_BASE}/user/login`, {
      method : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body   : JSON.stringify({ username, password })
    });
    const data = await response.json();

    if (!response.ok || !data.role) {
      return res.render('login', {
        title : 'Log in',
        error : data.message || 'Invalid credentials',
        user  : null
      });
    }

    req.session.user = { username, role: data.role };

    if (['institution_representative','representative']
        .includes(data.role))      return res.redirect('/institution');
    else if (data.role === 'instructor') return res.redirect('/instructor');
    else if (data.role === 'student')    return res.redirect('/student');
    else                                 return res.redirect('/');
  } catch (err) {
    return res.render('login', {
      title : 'Log in',
      error : 'Login failed',
      user  : null
    });
  }
});

app.post('/api/session', (req, res) => {
  const { username, role } = req.body;
  if (!username || !role) {
    return res.status(400).json({ error: 'username and role required' });
  }
  req.session.user = { username, role };
  res.sendStatus(200);
});

app.get('/logout', (req, res) =>
  req.session.destroy(() => res.redirect('/login'))
);

// Student UI
app.get('/student',            auth('student'), (req,res)=>res.render('student/dashboard',    { user:req.session.user, title:'Dashboard' }));
app.get('/student/statistics', auth('student'), (req,res)=>res.render('student/statistics',   { user:req.session.user, title:'Statistics' }));
app.get('/student/my-courses', auth('student'), (req,res)=>res.render('student/myCourses',    { user:req.session.user, title:'My Courses' }));
app.get('/student/request',    auth('student'), (req,res)=>res.render('student/reviewRequest',{ user:req.session.user, title:'Review Request' }));
app.get('/student/status',     auth('student'), (req,res)=>res.render('student/reviewStatus', { user:req.session.user, title:'Review Status' }));
app.get('/student/personal',   auth('student'), (req,res)=>res.render('student/personal',     { user:req.session.user, title:'Personal Grades' }));

// Instructor UI
app.get('/instructor',              auth('instructor'), (req,res)=>res.render('instructor/dashboard', { user:req.session.user, title:'Dashboard' }));
app.get('/instructor/post-initial', auth('instructor'), (req,res)=>res.render('instructor/postInitial',{ user:req.session.user, title:'Post Initial' }));
app.get('/instructor/post-final',   auth('instructor'), (req,res)=>res.render('instructor/postFinal',  { user:req.session.user, title:'Post Final' }));
app.get('/instructor/review-list',  auth('instructor'), (req,res)=>res.render('instructor/reviewList', { user:req.session.user, title:'Review Requests' }));
app.get('/instructor/reply',        auth('instructor'), (req,res)=>{
  const request_id = req.query.req || '';
  res.render('instructor/replyForm',{
    user        : req.session.user,
    title       : 'Reply to Review Request',
    request_id,
    course_name : 'software II',
    exam_period : 'spring 2025',
    student_name: 'john doe',
  });
});
app.get('/instructor/statistics',   auth('instructor'), (req,res)=>res.render('instructor/statistics', { user:req.session.user, title:'Statistics' }));

// Institution UI
app.get('/institution',                 auth('institution'), (req,res)=>res.render('institution/dashboard',      { user:req.session.user, title:'Dashboard' }));
app.get('/institution/register',        auth('institution'), (req,res)=>res.render('institution/register',       { user:req.session.user, title:'Register' }));
app.get('/institution/purchase',        auth('institution'), (req,res)=>res.render('institution/purchase',       { user:req.session.user, title:'Purchase' }));
app.get('/institution/user-management', auth('institution'), (req,res)=>res.render('institution/userManagement', { user:req.session.user, title:'Users' }));
app.get('/institution/statistics',      auth('institution'), (req,res)=>res.render('institution/statistics',     { user:req.session.user, title:'Statistics' }));

// ─────────────────────────────────────────────────────────────────────────────
// 10) Server start-up
// ─────────────────────────────────────────────────────────────────────────────
const PORT = process.env.PORT || 3000;
app.listen(PORT, () =>
  console.log(`✔ Front-end listening at http://localhost:${PORT}`)
);


===== front-end/public/api/credits.js =====
// credits.js
import { request } from './_request.js';

/**
 * Purchase credits for a given institution.
 * @param {{ name: string, amount: number }} payload
 */
export const purchaseCredits = ({ name, amount }) =>
  request('/purchase', {
    method: 'PATCH',
    body: { name, amount }
  });

export const getMyCredits = () =>
  request('/mycredits');

export const spendCredits = (amount, reason) =>
  request('/spending', {
    method: 'PATCH',
    body: { amount, reason }
  });

===== front-end/public/api/index.js =====
export * from './credits.js';
export * from './institution.js';
export * from './stats.js';
export * from './personal.js';
export * from './student.js';
export * from './instructor.js';
export * from './users.js';

===== front-end/public/api/institution.js =====
// institution.js
import { request } from './_request.js';

export const registerInstitution = ({ name, domain, email }) =>
  request('/registration', { method: 'POST', body: { name, domain, email } });

export const uploadInitialGrades = file => {
  const fd = new FormData();
  fd.append('xlsx', file);
  return request('/upload_init', { method: 'POST', body: fd });
};

===== front-end/public/api/instructor.js =====
// public/api/instructor.js
import { request } from './_request.js';

/**
 * Fetch pending review requests for the current instructor.
 * orchestrator: PATCH /instructor/review-list
 */
export const getPendingReviews = ({ course_id, exam_period }) =>
  request('/instructor/review-list', {
    method : 'PATCH',
    body   : { course_id, exam_period }
  });

/**
 * Send an instructor’s reply to a specific student request.
 * orchestrator: PATCH /instructor/reply
 */
export const postInstructorReply = ({
  user_id,                // student’s user_id from URL
  course_id,
  exam_period,
  instructor_reply_message,
  instructor_action
}) =>
  request('/instructor/reply', {
    method : 'PATCH',
    body   : {
      user_id,
      course_id,
      exam_period,
      instructor_reply_message,
      instructor_action
    }
  });

===== front-end/public/api/personal.js =====
// front-end/public/api/personal.js
import { request } from './_request.js';

/**
 * Fetch all past/future courses & periods for the logged-in student.
 * Orchestrator: GET /personal/grades → { status, data: […] }
 */
export const getStudentCourses = async () => {
  const { data } = await request('/personal/grades');
  return Array.isArray(data) ? data : [];
};

/**
 * Fetch the grade entries for a given course & exam period.
 * Orchestrator: GET /personal/grades?course_id=…&exam_period=…
 */
export const getPersonalGrades = async ({ course_id, exam_period }) => {
  const qs = new URLSearchParams();
  if (course_id)   qs.append('course_id',   course_id);
  if (exam_period) qs.append('exam_period', exam_period);

  const suffix = qs.toString() ? `?${qs}` : '';
  const { data } = await request(`/personal/grades${suffix}`);
  return Array.isArray(data) ? data : [];
};

===== front-end/public/api/_request.js =====
// front-end/public/api/_request.js

// NOTE: in your browser, "orchestrator" isn't a DNS name.
// Use localhost:8080 (or adjust if you run the orchestrator elsewhere).
const API_BASE = 'http://localhost:8080';

/**
 * Read the JWT from localStorage (or cookie fallback).
 */
function getJWT() {
  const fromLS = window.localStorage?.getItem('jwt');
  if (fromLS) return fromLS;
  const m = document.cookie.match(/(?:^|;\s*)jwt=([^;]+)/);
  return m ? decodeURIComponent(m[1]) : null;
}

/**
 * Generic request helper that:
 *  • automatically JSON‐stringifies objects
 *  • sends FormData unchanged
 *  • injects `Authorization: Bearer <token>` if you have a JWT
 */
export async function request(path, { method = 'GET', body, headers } = {}) {
  console.log('→ [API]', method, path, 'body:', body);

  const opts = { method, headers: { ...headers } };
  const token = getJWT();
  if (token && !opts.headers.Authorization) {
    opts.headers.Authorization = `Bearer ${token}`;
  }

  if (body instanceof FormData) {
    opts.body = body;
  } else if (body !== undefined) {
    opts.body = JSON.stringify(body);
    opts.headers = { 'Content-Type': 'application/json', ...opts.headers };
  }

  const res = await fetch(`${API_BASE}${path}`, opts);
  const json = await res.json().catch(() => ({}));

  if (!res.ok) {
    throw new Error(json.message || json.error || res.statusText);
  }
  return json;
}

===== front-end/public/api/stats.js =====
// stats.js
import { request } from './_request.js';

export const persistAndCalculateStats = payload =>
  request('/stats/persist', { method: 'POST', body: payload });

export const getDistributions = filters =>
  request('/stats/distributions', { method: 'POST', body: filters });

===== front-end/public/api/student.js =====
// student.js
import { request } from './_request.js';

/**
 * Submit a new review request.
 * orchestrator: PATCH /student/reviewRequest
 */
export const postReviewRequest = ({ course_id, exam_period, student_message }) =>
  request('/student/reviewRequest', {
    method : 'PATCH',
    body   : { course_id, exam_period, student_message }
  });

/**
 * Check review status.
 * orchestrator: PATCH /student/status
 */
export const getReviewStatus = ({ course_id, exam_period }) =>
  request('/student/status', {
    method : 'PATCH',
    body   : { course_id, exam_period }
  });

===== front-end/public/api/users.js =====
import { request } from './_request.js';

/**
 * Register a new user.
 * @param {{ username: string, password: string, role: string, student_id?: string }} payload
 */
export const registerUser = ({ username, password, role, student_id }) =>
  request('/user/register', {
    method: 'POST',
    body  : { username, password, role, student_id }
  }).then(response => {
    if (response.error) throw new Error(response.error);
    return response;
  });

/**
 * Log in an existing user.
 */
export const loginUser = ({ username, password }) =>
  request('/user/login', {
    method: 'POST',
    body  : { username, password }
  }).then(response => {
    if (!response.role) throw new Error(response.message || 'Login failed');
    if (response.token) localStorage.setItem('jwt', response.token);
    return response;
  });

/**
 * Change password for an existing user.
 * @param {{ username: string, old_password: string, new_password: string }} payload
 */
export const changePassword = ({ username, old_password, new_password }) =>
  request('/user/change-password', {
    method: 'PATCH',
    body  : { username, old_password, new_password }
  });

/**
 * Login via Google token.
 * @param {string} token  Google ID token
 * @param {string} role   User role (optional)
 */
export const googleLoginUser = (token, role = 'institution_representative') =>
  request('/user/google-login', {
    method: 'POST',
    body  : { token, role }
  }).then(response => {
    if (response.token) localStorage.setItem('jwt', response.token);
    return response;
  });

===== front-end/public/js/auth/login.js =====
// front-end/public/js/auth/login.js
import { flash } from '../../script.js';
import { loginUser } from '../../api/users.js';

const form     = document.querySelector('#login-form');
const errorMsg = document.querySelector('#error-msg');

form.addEventListener('submit', async e => {
  e.preventDefault();
  errorMsg.style.display = 'none';

  // ──────────────────────────────────────────────────────────────
  // 1) Build payload (username or e-mail)
  // ──────────────────────────────────────────────────────────────
  const input    = form.username.value.trim();
  const password = form.password.value;
  const isEmail  = /^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(input);
  const payload  = isEmail
    ? { email: input, password }
    : { username: input, password };

  try {
    // ────────────────────────────────────────────────────────────
    // 2) Ask orchestrator to log us in → { role, token }
    // ────────────────────────────────────────────────────────────
    const { role, token } = await loginUser(payload);

    // 3) Persist JWT so every future fetch() carries Authorization: Bearer …
    localStorage.setItem('jwt', token);

    // 4) Tell the Express layer to remember who we are (for EJS templates)
    await fetch('/api/session', {
      method : 'POST',
      headers: { 'Content-Type': 'application/json' },
      body   : JSON.stringify({
        username: input,
        role
      })
    });

    // ────────────────────────────────────────────────────────────
    // 5) Redirect according to role
    // ────────────────────────────────────────────────────────────
    if (['institution_representative', 'representative'].includes(role)) {
      window.location.href = '/institution';
    } else if (role === 'instructor') {
      window.location.href = '/instructor';
    } else if (role === 'student') {
      window.location.href = '/student';
    } else {
      window.location.href = '/';
    }
  } catch (err) {
    errorMsg.textContent = err.message;
    errorMsg.style.display = 'block';
  }
});

===== front-end/public/js/auth/logout.js =====
// front-end/public/js/auth/logout.js
import { flash } from '../../script.js';

const logoutBtn = document.querySelector('#logout-button');
if (logoutBtn) {
  logoutBtn.addEventListener('click', e => {
    e.preventDefault();
    // Remove JWT so future API calls are unauthenticated
    localStorage.removeItem('jwt');
    flash('Logged out');
    window.location.href = '/login';
  });
}

===== front-end/public/js/auth/signup.js =====
// auth/signup.js
import { flash } from '../../script.js';
import { registerUser } from '../../api/users.js';

const form = document.querySelector('main form');

form.addEventListener('submit', async e => {
  e.preventDefault();
  const role     = form.role.value;
  const username = form.username.value.trim();
  const password = form.password.value;

  if (!username || !password) {
    return flash('Username and password are required');
  }
  try {
    await registerUser({ username, password, role });
    flash('Signup successful! Redirecting to login…');
    setTimeout(() => (window.location.href = '/login'), 1500);
  } catch (err) {
    flash(`Error: ${err.message}`);
  }
});

===== front-end/public/js/institution/post-final.js =====
// front-end/public/js/institution/post-final.js
//
// Upload the FINAL grades spreadsheet (credits will be deducted)
// ────────────────────────────────────────────────────────────────
import { flash }    from '../../script.js';
import { request }  from '../../api/_request.js';   // ✅ helper injects JWT

const form = document.querySelector('#upload-final-form');

form.addEventListener('submit', async (e) => {
  e.preventDefault();

  const fileInput = form.querySelector('input[type="file"]');
  if (!fileInput.files.length) {
    return flash('Please select an XLSX file.');
  }

  const fd = new FormData();
  fd.append('file', fileInput.files[0]);            // ↔ name="file" in the form

  try {
    // ────────────────────────────────────────────────────────────
    // •  PATCH /postFinalGrades  (route guarded for instructors)
    // •  request() adds  Authorization: Bearer <jwt>
    // ────────────────────────────────────────────────────────────
    await request('/postFinalGrades', { method: 'PATCH', body: fd });
    flash('Final grades uploaded ✔');
  } catch (err) {
    flash(err.message || 'Upload failed');
  }
});

===== front-end/public/js/institution/post-initial.js =====
// front-end/public/js/institution/post-initial.js
//
// Upload INITIAL grades (first declaration)
// ─────────────────────────────────────────────────────────────
import { flash }   from '../../script.js';
import { request } from '../../api/_request.js';   // ← adds the JWT

const form = document.querySelector('#upload-init-form');

form.addEventListener('submit', async (e) => {
  e.preventDefault();

  const fileInput = form.querySelector('input[type="file"]');
  if (!fileInput.files.length) {
    return flash('Please select an XLSX file.');
  }

  const fd = new FormData();
  fd.append('file', fileInput.files[0]);           // name="file" matches Gin handler

  try {
    // The Orchestrator route is a **POST /upload_init** (instructor-only)
    await request('/upload_init', { method: 'POST', body: fd });
    flash('Initial grades uploaded ✔');
  } catch (err) {
    flash(err.message || 'Upload failed');
  }
});

===== front-end/public/js/institution/purchase.js =====
import { flash } from '../../script.js';
import { purchaseCredits } from '../../api/credits.js';

console.log('🛠️ purchase.js loaded');

const form = document.querySelector('#purchase-form');
if (!form) {
  console.error('⚠️ #purchase-form not found!');
} else {
  form.addEventListener('submit', async e => {
    e.preventDefault();
    console.log('🛠️ submit event fired');

    const instName = form.instName.value.trim();
    const amount = Number(form.amount.value);
    console.log('🛠️ form values:', { instName, amount });

    try {
      const response = await purchaseCredits({ name: instName, amount });
      console.log('🛠️ API response:', response);

      // orchestrator now returns { status, message }
      if (response.message) {
        flash(response.message);
      } else {
        flash('Purchased successfully!');
      }
    } catch (err) {
      console.error('🛠️ purchaseCredits error:', err);
      flash(err.message || 'Purchase failed');
    }
  });
}

===== front-end/public/js/institution/register.js =====
// institution/register.js
import { flash } from '../../script.js';
import { registerInstitution } from '../../api/institution.js';

const form = document.querySelector('#register-inst-form');

form.addEventListener('submit', async e => {
  e.preventDefault();
  const name   = form.name.value.trim();
  const domain = form.domain.value.trim();
  const email  = form.email.value.trim();

  try {
    await registerInstitution({ name, domain, email });
    flash('Institution registered!');
  } catch (err) {
    flash(err.message);
  }
});

===== front-end/public/js/institution/statistics.js =====
// public/js/institution/statistics.js
import { flash } from '../../script.js';
import { getDistributions } from '../../api/stats.js';

const btn = document.querySelector('button.button--secondary');

btn.addEventListener('click', async () => {
  try {
    const stats = await getDistributions({ /* filters */ });
    console.log('Distributions:', stats);
    flash('Distributions fetched—check console.');
  } catch (err) {
    flash(err.message);
  }
});

===== front-end/public/js/institution/user-management.js =====
import { flash } from '../../script.js';
import { registerUser, changePassword } from '../../api/users.js';

const form            = document.querySelector('#user-mgmt-form');
const roleSelect      = document.querySelector('#role');
const studentIdGroup  = document.querySelector('#student-id-group');

// Show/hide Student ID field
roleSelect.addEventListener('change', () => {
  studentIdGroup.style.display =
    roleSelect.value === 'student' ? 'block' : 'none';
});

// Add user handler
form.addEventListener('submit', async e => {
  e.preventDefault();

  const username   = form.username.value.trim();
  const password   = form.password.value;
  const role       = form.role.value;
  const student_id = role === 'student'
    ? form.student_id.value.trim()
    : undefined;

  if (!username || !password) {
    return flash('Username and password are required');
  }

  try {
    await registerUser({ username, password, role, student_id });
    flash('User added!');
    form.reset();
    studentIdGroup.style.display = 'none';
  } catch (err) {
    flash(`Error: ${err.message}`);
  }
});

// Change password handler
const changeForm = document.querySelector('#change-pass-form');
changeForm.addEventListener('submit', async e => {
  e.preventDefault();

  const payload = {
    username     : changeForm.username.value.trim(),
    old_password : changeForm.old_password.value,
    new_password : changeForm.new_password.value
  };

  try {
    await changePassword(payload);
    flash('Password changed ✔');
    changeForm.reset();
  } catch (err) {
    flash(`Error: ${err.message}`);
  }
});

===== front-end/public/js/instructor/reply.js =====
// public/js/instructor/reply.js
import { flash } from '../../script.js';
import { postInstructorReply } from '../../api/instructor.js';

const form = document.querySelector('#instructor-reply-form');

form.addEventListener('submit', async e => {
  e.preventDefault();

  const params       = new URLSearchParams(location.search);
  const user_id      = params.get('req');                // the student’s ID
  const course_id    = 'software II';                    // or pull from hidden input
  const exam_period  = 'spring 2025';                    // likewise
  const instructor_reply_message = form.message.value.trim();
  const instructor_action        = form.decision.value;

  try {
    await postInstructorReply({
      user_id,
      course_id,
      exam_period,
      instructor_reply_message,
      instructor_action
    });
    flash('Reply sent!');
    // Optionally redirect back to the list:
    // window.location.href = '/instructor/review-list';
  } catch (err) {
    flash(err.message);
  }
});

===== front-end/public/js/instructor/review-list.js =====
// public/js/instructor/review-list.js
import { flash } from '../../script.js';
import { getPendingReviews } from '../../api/instructor.js';

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const payload = { course_id: 'software II', exam_period: 'spring 2025' };
    // API now returns the array directly
    const reviews = await getPendingReviews(payload);

    const tbody = document.querySelector('table tbody');
    tbody.innerHTML = reviews
      .map(r => `
        <tr>
          <td>${r.course_name}</td>
          <td>${r.exam_period}</td>
          <td>${r.student}</td>
          <td>
            <a class="button" href="/instructor/reply?req=${r.id}">Reply</a>
          </td>
        </tr>
      `)
      .join('');
  } catch (err) {
    flash(err.message);
  }
});

===== front-end/public/js/student/my-courses.js =====
// front-end/public/js/student/my-courses.js
//
// Shows all courses for the logged-in student and builds action links
// that carry ONLY the numeric course_id (e.g. 3205).
// ────────────────────────────────────────────────────────────────────
import { flash } from '../../script.js';
import { getStudentCourses } from '../../api/personal.js';

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const courses = await getStudentCourses();         // array from /personal/grades
    const tbody   = document.querySelector('table tbody');

    if (!courses.length) {
      tbody.innerHTML = `
        <tr><td colspan="4" style="text-align:center;">No courses found.</td></tr>`;
      return;
    }

    tbody.innerHTML = courses.map(c => {
      /* ── 1) Resolve display fields ─────────────────────────────── */
      const courseName = c.classTitle        ?? c.course_name  ?? '—';
      const examPeriod = c.declarationPeriod ?? c.exam_period  ?? '—';

      let status = c.status ?? c.grading_status;
      if (typeof status === 'number') status = status === 0 ? 'open' : 'closed';
      if (!status) status = '—';

      /* ── 2) Derive a clean numeric course-id for links ─────────── */
      const rawId = c.course_id ?? c.id ?? courseName;  // whatever we’ve got
      const numericId =
        String(rawId).match(/\((\d+)\)/)?.[1]   // digits inside ( ... )
        || String(rawId).replace(/\D/g, '')     // else keep any digits
        || encodeURIComponent(rawId);           // fallback

      /* ── 3) Build row ──────────────────────────────────────────── */
      return `
        <tr ${status === 'open' ? 'style="background:#e6e7ea;"' : ''}>
          <td>${courseName}</td>
          <td>${examPeriod}</td>
          <td>${status}</td>
          <td>
            <a class="button"
               href="/student/personal?course=${numericId}&period=${encodeURIComponent(examPeriod)}">
              View grades
            </a>

            <a class="button${status !== 'open' ? ' button--secondary' : ''}"
               href="/student/request?course=${numericId}&period=${encodeURIComponent(examPeriod)}">
              Ask review
            </a>

            <a class="button${status === 'open' ? ' button--secondary' : ''}"
               href="/student/status?course=${numericId}&period=${encodeURIComponent(examPeriod)}">
              Status
            </a>
          </td>
        </tr>`;
    }).join('');
  } catch (err) {
    flash(err.message || 'Failed to load courses');
  }
});

===== front-end/public/js/student/personal.js =====
// front-end/public/js/student/personal.js
import { flash } from '../../script.js';
import { getPersonalGrades } from '../../api/personal.js';

window.addEventListener('DOMContentLoaded', async () => {
  const params      = new URLSearchParams(location.search);
  const course_id   = params.get('course');
  const exam_period = params.get('period');

  if (!course_id) {
    flash('Please pick a course first');
    location.href = '/student/my-courses';
    return;
  }

  try {
    const grades = await getPersonalGrades({ course_id, exam_period });
    const tbody  = document.querySelector('table tbody');

    if (!grades.length) {
      tbody.innerHTML = `
        <tr>
          <td colspan="4" style="text-align:center;">No grades found.</td>
        </tr>`;
      return;
    }

    tbody.innerHTML = grades.map(g => {
      const period = g.declarationPeriod ?? g.declaration_period ?? '—';
      const course = g.classTitle        ?? g.class_title        ?? '—';
      const status = g.gradingStatus     ?? g.grading_status     ?? '—';
      const score  = g.grade             ?? g.score              ?? '—';

      return `
        <tr>
          <td>${period}</td>
          <td>${course}</td>
          <td>${status}</td>
          <td>${score}</td>
        </tr>`;
    }).join('');
  } catch (err) {
    flash(err.message || 'Failed to load grades');
  }
});

===== front-end/public/js/student/review-request.js =====
// front-end/public/js/student/review-request.js
//
// Submits a grade-review request. Ensures `course_id` contains
// only the numeric part before sending it to /student/reviewRequest.
// ────────────────────────────────────────────────────────────────────
import { flash } from '../../script.js';
import { postReviewRequest } from '../../api/student.js';

const form = document.querySelector('#student-review-request-form');
if (!form) {
  console.error('Student review request form (#student-review-request-form) not found!');
} else {
  form.addEventListener('submit', async e => {
    e.preventDefault();

    const params = new URLSearchParams(location.search);

    /* ── 1) Extract & sanitise course_id ─────────────────────────── */
    let course_id = params.get('course');                 // could be “ΤΕΧΝ… (3205)”
    if (course_id) {
      course_id = course_id.match(/\((\d+)\)/)?.[1]       // digits inside (...)
               || course_id.replace(/\D/g, '');           // any digits
    }

    const exam_period     = params.get('period') || undefined;
    const student_message = form.message.value.trim();

    if (!course_id) {
      flash('Course id missing – please navigate from “My courses” page.');
      location.href = '/student/my-courses';
      return;
    }

    try {
      await postReviewRequest({ course_id, exam_period, student_message });
      flash('Review request submitted!');
      form.reset();
    } catch (err) {
      flash(err.message || 'Failed to submit review request');
    }
  });
}

===== front-end/public/js/student/review-status.js =====
// front-end/public/js/student/review-status.js
import { flash } from '../../script.js';
import { getReviewStatus } from '../../api/student.js';

window.addEventListener('DOMContentLoaded', async () => {
  const params      = new URLSearchParams(location.search);
  const course_id   = params.get('course');
  const exam_period = params.get('period');   // optional

  if (!course_id) {
    flash('Please pick a course first');
    window.location.href = '/student/my-courses';
    return;
  }

  try {
    const { data } = await getReviewStatus({ course_id, exam_period });
    document.querySelector('textarea[readonly]').textContent =
      data.instructor_message || 'No response yet.';
  } catch (err) {
    flash(err.message);
  }
});

===== front-end/public/js/student/statistics.js =====
// student/statistics.js
import { flash } from '../../script.js';
import { getDistributions } from '../../api/stats.js';

window.addEventListener('DOMContentLoaded', async () => {
  try {
    const { data } = await getDistributions({ /* filters */ });
    console.log('Stats:', data);
    flash('Statistics loaded—see console.');
  } catch (err) {
    flash(err.message);
  }
});

===== front-end/public/script.js =====
// optional flash helper
export function flash(msg) {
  const d = document.createElement("div");
  d.textContent = msg;
  d.style.cssText =
    "position:fixed;top:1rem;right:1rem;background:#006dd0;color:#fff;padding:0.5rem 1rem;border-radius:4px;z-index:1000";
  document.body.appendChild(d);
  setTimeout(() => d.remove(), 3000);
}

===== front-end/public/styles.css =====
/* 0) Make every element use border-box */
*, *::before, *::after {
  box-sizing: border-box;
}

/* 1) Full-width reset */
html, body {
  height: 100%;
  width: 100%;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
body {
  display: flex;
  flex-direction: column;
  font-family: Arial, sans-serif;
  background: var(--bg);
  color: #333;
  min-height: 100vh;
}

/* 2) CSS variables */
:root {
  --primary:       #006dd0;
  --primary-dark:  #004c97;
  --secondary:     #69727d;
  --bg:            #f5f7fa;
  --card-bg:       #fff;
  --radius:        0.5rem;
  --gap:           1rem;
}

/* 1) Fluid full-width container without overflow */
.container {
  width: 100%;         /* fill the viewport */
  max-width: 100%;     /* never exceed it */
  margin: 0;           /* drop any auto-margins */
  padding: 1rem 2rem;  /* internal gutters */
}

/* Login page wrapper (only on /login) */
.login-container {
  width: 100%;
  max-width: 380px;            /* constrain form width */
  margin: auto;                /* center horizontally & vertically */
  min-height: calc(100vh - 70px); /* push below the sticky navbar */
  display: flex;
  flex-direction: column;
  justify-content: center;     /* vertical centering */
  padding: 1rem;
  box-sizing: border-box;
}



/* 4) Card component */
.card {
  background: var(--card-bg);
  border-radius: var(--radius);
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  padding: 1.5rem;
  transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.card:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* 5) Dashboard grid */
.dashboard-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: var(--gap);
}

/* 6) Button-link for cards */
.button-link {
  display: flex;
  align-items: center;
  justify-content: center;
  text-decoration: none;
  color: inherit;
  height: 100px;
  font-weight: 600;
}

/* 7) Sticky full-width navbar */
nav.navbar, nav {
  background: var(--primary-dark);
  color: #fff;
  display: flex;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  position: sticky;
  top: 0;
  width: 100%;
  z-index: 100;
}
nav a { 
  color: #fff; 
  text-decoration: none; 
  margin-left: 1rem; 
}

/* 8) Primary buttons (you can keep your old .button if you want, but update colors) */
.button {
  background: var(--primary);
  color: #fff;
  padding: 0.35rem 0.9rem;
  border: none;
  border-radius: 4px;
  text-decoration: none;
  cursor: pointer;
}
.button--secondary { 
  background: var(--secondary); 
}

/* 9) Utilities */
.mt-2 { margin-top: 2rem; }

/* 10) Keep the rest of your existing styles unchanged */
table {
  width: 100%;
  border-collapse: collapse;
  margin: 1rem 0;
}
th, td {
  border: 1px solid #d0d7de;
  padding: 0.45rem;
  text-align: left;
}
th { background: #ebf1f8; }

fieldset {
  border: 1px solid #c2c5c9;
  padding: 1rem;
  margin-bottom: 1rem;
}
legend { font-weight: bold; }

.panel {
  border: 1px solid #c2c5c9;
  margin: 1rem 0;
}
.panel-header {
  background: #e6e7ea;
  padding: 0.45rem 0.6rem;
  font-weight: bold;
}

.form-group {
  margin-bottom: 0.6rem;
}
label {
  display: block;
  margin-bottom: 0.25rem;
}
input, select, textarea {
  width: 100%;
  padding: 0.45rem;
  border: 1px solid #ccd1d6;
  border-radius: 4px;
}

/* If you have additional .navbar__* rules, leave them intact below */
.navbar__brand a { color: #fff; font-weight: 600; text-decoration: none; font-size: 1.2rem }
.navbar__links { display: flex; gap: 1.1rem; list-style: none; margin: 0; padding: 0 }
.navbar__links a { color: #fff; text-decoration: none }
.navbar__links .active { border-bottom: 2px solid #ffeb3b }
.navbar__auth { display: flex; align-items: center; gap: 0.8rem; }

===== front-end/views/institution/dashboard.ejs =====
<!DOCTYPE html><html lang="en"><head>
  <%- include('../partials/head',{title}) %>
</head><body>
  <%- include('../partials/navbar',{user}) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h1>Institution Dashboard</h1>
    <ul>
      <div class="dashboard-grid mt-2">
        <a href="/institution/register"       class="card button-link">1. Register institution</a>
        <a href="/institution/purchase"       class="card button-link">2. Purchase credits</a>
        <a href="/institution/statistics"     class="card button-link">3. View statistics</a>
        <a href="/institution/user-management"    class="card button-link">4. User Management</a>

      </div>

  </main>
</body></html>

===== front-end/views/institution/purchase.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head',{ title }) %>
</head>
<body>
  <%- include('../partials/navbar',{ user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <fieldset class="purchase-panel">
      <legend>Buy credits</legend>
      <form id="purchase-form">
        <div class="purchase-row">
          <div class="form-group">
            <label for="inst-name">Institution:</label>
            <select id="inst-name" name="instName" required>
              <option value="NTUA">NTUA</option>
              <option value="EKPA">EKPA</option>
            </select>
          </div>
          <div class="form-group">
            <label for="amount">Amount:</label>
            <input id="amount" type="number" name="amount" min="1" required/>
          </div>
          <div class="form-group form-group--button">
            <button class="button" type="submit">Buy</button>
          </div>
        </div>
      </form>
    </fieldset>
    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/institution/purchase.js"></script>
</body>
</html>

===== front-end/views/institution/register.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head',{title}) %>
</head>
<body>
  <%- include('../partials/navbar',{user}) %>
  <main class="container">
    <%- include('../partials/header') %>
    <fieldset><legend>Institutions</legend>
      <form id="register-inst-form">
        <div class="form-group"><label>Name</label><input name="name" required/></div>
        <div class="form-group"><label>Domain</label><input name="domain" required/></div>
        <div class="form-group"><label>Contact e-mail</label><input name="email" type="email" required/></div>
        <button class="button" type="submit">Save</button>
      </form>
    </fieldset>
    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/institution/register.js"></script>
</body>
</html>

===== front-end/views/institution/statistics.ejs =====
<!DOCTYPE html><html lang="en"><head>
  <%- include('../partials/head',{title}) %>
</head><body>
  <%- include('../partials/navbar',{user}) %>
  <main class="container">
    <%- include('../partials/header') %>
    <div class="panel">
      <div class="panel-header">Available course statistics
        <button class="button button--secondary" style="float:right;">filter my courses</button>
      </div>
      <table>
        <thead><tr><th>course name</th><th>exam period</th><th>initial submission</th><th>final submission</th></tr></thead>
        <tbody><tr><td>physics</td><td>fall 2024</td><td>2025‑02‑22</td><td>2025‑02‑28</td></tr></tbody>
      </table>
      <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:0.6rem;margin-top:1rem;">
        <% for(let i=0;i<6;i++){ %>
          <div style="border:1px solid #d0d7de;height:120px;">chart</div>
        <% } %>
      </div>
    </div>
  </main>
</body></html>

===== front-end/views/institution/userManagement.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head',{ title }) %>
</head>
<body>
  <%- include('../partials/navbar',{ user }) %>
  <main class="container">
    <%- include('../partials/header') %>

    <!-- Add User -->
    <fieldset>
      <legend>Users</legend>
      <form id="user-mgmt-form" novalidate>
        <div class="form-group">
          <label for="username">Username</label>
          <input id="username" name="username" type="text" required />
        </div>

        <div class="form-group">
          <label for="password">Password</label>
          <input id="password" name="password" type="password" required />
        </div>

        <div class="form-group">
          <label for="role">Type</label>
          <select id="role" name="role" required>
            <option value="institution_representative">Institution representative</option>
            <option value="instructor">Instructor</option>
            <option value="student">Student</option>
          </select>
        </div>

        <div class="form-group" id="student-id-group" style="display:none;">
          <label for="student_id">Student&nbsp;ID</label>
          <input id="student_id" name="student_id" type="text" placeholder="e.g. 031200000" />
        </div>

        <div class="form-group form-group--button" style="display:flex;gap:0.5rem;">
          <button class="button" type="submit">Add user</button>
        </div>
      </form>
    </fieldset>

    <!-- Change Password -->
    <fieldset class="mt-2">
      <legend>Change password</legend>
      <form id="change-pass-form" novalidate>
        <div class="form-group">
          <label for="cp-username">Username</label>
          <input id="cp-username" name="username" required />
        </div>

        <div class="form-group">
          <label for="cp-old">Current password</label>
          <input id="cp-old" name="old_password" type="password" required />
        </div>

        <div class="form-group">
          <label for="cp-new">New password</label>
          <input id="cp-new" name="new_password" type="password" required minlength="6" />
        </div>

        <div class="form-group form-group--button">
          <button class="button" type="submit">Change password</button>
        </div>
      </form>
    </fieldset>

    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/institution/user-management.js"></script>
</body>
</html>

===== front-end/views/instructor/dashboard.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'Instructor Dashboard' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h1>Instructor Dashboard</h1>
    <div class="dashboard-grid mt-2">
      <a href="/instructor/post-initial" class="card button-link">1. Post initial grades</a>
      <a href="/instructor/review-list"  class="card button-link">2. Review requests</a>
      <a href="/instructor/reply"        class="card button-link">3. Reply to request</a>
      <a href="/instructor/post-final"   class="card button-link">4. Post final grades</a>
      <a href="/instructor/statistics"   class="card button-link">5. View grade statistics</a>
    </div>

  </main>
</body>
</html>

===== front-end/views/instructor/postFinal.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'Post Final Grades' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Instructor: <%= user.username %></h2>

    <fieldset><legend>FINAL GRADES POSTING</legend>
      <!-- No action/method → handled by JS -->
      <form id="upload-final-form" enctype="multipart/form-data">
        <div class="form-group">
          <label for="xlsx-final">XLSX file with FINAL grades</label>
          <input id="xlsx-final" type="file" name="file"
                 accept=".xlsx" style="width:100%;margin:0.4rem 0;" required />
        </div>
        <button class="button" type="submit">Submit Final Grades</button>
      </form>
    </fieldset>

    <fieldset><legend>XLSX file parsing (preview)</legend>
      <div class="form-group"><label>Course:</label><input readonly value="" /></div>
      <div class="form-group"><label>Period:</label><input readonly value="" /></div>
      <div class="form-group"><label>Number of grades:</label><input readonly value="" style="width:120px"/></div>
      <button class="button">CONFIRM</button>
      <button class="button button--secondary">CANCEL</button>
    </fieldset>

    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/institution/post-final.js"></script>
</body>
</html>

===== front-end/views/instructor/postInitial.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'Post Initial Grades' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Instructor: <%= user.username %></h2>

    <fieldset><legend>INITIAL GRADES POSTING</legend>
      <!-- No action/method → handled by JS -->
      <form id="upload-init-form" enctype="multipart/form-data">
        <div class="form-group">
          <label for="xlsx-init">XLSX file with initial grades</label>
          <input id="xlsx-init" type="file" name="file"
                 accept=".xlsx" style="width:100%;margin:0.4rem 0;" required />
        </div>
        <button class="button" type="submit">Submit Initial Grades</button>
      </form>
    </fieldset>

    <fieldset><legend>XLSX file parsing (preview)</legend>
      <div class="form-group"><label>Course:</label><input readonly value="" /></div>
      <div class="form-group"><label>Period:</label><input readonly value="" /></div>
      <div class="form-group"><label>Number of grades:</label><input readonly value="" style="width:120px"/></div>
      <button class="button">CONFIRM</button>
      <button class="button button--secondary">CANCEL</button>
    </fieldset>

    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/institution/post-initial.js"></script>
</body>
</html>

===== front-end/views/instructor/replyForm.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'Reply to Review Request' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Instructor: <%= user.username %></h2>

    <!-- Review list table above omitted for brevity -->

    <div class="panel">
      <div class="panel-header">
        REPLY TO GRADE REVIEW REQUEST&nbsp;&nbsp;
        <%= course_name %>&nbsp;<%= exam_period %>&nbsp;<%= student_name %>
      </div>

      <!-- JS-driven reply form -->
      <form id="instructor-reply-form">
        <input type="hidden" name="req" value="<%= request_id %>" />

        <div class="form-group">
          <label>Action</label>
          <select name="decision" style="width:180px;">
            <option value="Total accept">Total accept</option>
            <option value="Partial accept">Partial accept</option>
            <option value="Reject">Reject</option>
          </select>
        </div>

        <div class="form-group">
          <label>Instructor's message</label>
          <textarea name="message" style="width:100%;height:80px;"></textarea>
        </div>

        <button class="button button--secondary" type="button">
          Upload attachment
        </button>
        <button class="button" type="submit" style="float:right;">
          Send Reply
        </button>
        <div style="clear:both;"></div>
      </form>
    </div>

    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/instructor/reply.js"></script>
</body>
</html>

===== front-end/views/instructor/reviewList.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'Review Requests' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Instructor: <%= user.username %></h2>

    <table>
      <thead>
        <tr>
          <th>Course Name</th>
          <th>Exam Period</th>
          <th>Student</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <!-- rows will be injected here by JS -->
      </tbody>
    </table>
  </main>

  <script type="module" src="/js/instructor/review-list.js"></script>
</body>
</html>

===== front-end/views/instructor/statistics.ejs =====
<!DOCTYPE html><html lang="en"><head>
  <%- include('../partials/head',{title}) %>
</head><body>
  <%- include('../partials/navbar',{user}) %>
  <main class="container">
    <%- include('../partials/header') %>
    <div class="panel">
      <div class="panel-header">Available course statistics
        <button class="button button--secondary" style="float:right;">filter my courses</button>
      </div>
      <table>
        <thead><tr><th>course name</th><th>exam period</th><th>initial submission</th><th>final submission</th></tr></thead>
        <tbody><tr><td>physics</td><td>fall 2024</td><td>2025‑02‑22</td><td>2025‑02‑28</td></tr></tbody>
      </table>
      <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:0.6rem;margin-top:1rem;">
        <% for(let i=0;i<6;i++){ %>
          <div style="border:1px solid #d0d7de;height:120px;">chart</div>
        <% } %>
      </div>
    </div>
  </main>
</body></html>

===== front-end/views/login.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <!-- meta + stylesheet + window.API_BASE -->
  <%- include('partials/head', { title: 'Log in' }) %>
</head>
<body>
  <!-- top navigation bar (guest version) -->
  <%- include('partials/navbar') %>

  <main class="login-container">
    <fieldset>
      <legend>Welcome to clearSKY</legend>

      <!-- CLASSIC form (the JS will intercept submit) -->
      <form id="login-form" action="/login" method="post">
        <div class="form-group">
          <label for="username">User name</label>
          <input id="username" name="username" required />
        </div>

        <div class="form-group">
          <label for="password">Password</label>
          <input id="password" name="password" type="password" required />
        </div>

        <button class="button" type="submit">Login</button>

        <!-- space for client-side errors -->
        <p id="error-msg" style="display:none;color:#c00;margin-top:1rem;"></p>
      </form>

      <!-- space for *server-side* errors from Express -->
      <% if (error) { %>
        <p style="color:#c00;margin-top:1rem;"><%= error %></p>
      <% } %>

      <!-- GOOGLE LOGIN BUTTON -->
      <a id="google-login-btn" class="button button--secondary"
         href="http://localhost:8086/auth/google/login"
         style="margin-top:0.75rem;display:inline-block;">
        Login with&nbsp;Google
      </a>
    </fieldset>
  </main>

  <!-- ──────────────────────────────────────────────────────────────
       Place scripts LAST so the DOM is ready when they run
       ────────────────────────────────────────────────────────────── -->
  <script type="module" src="/js/auth/login.js"></script>
</body>
</html>

===== front-end/views/partials/head.ejs =====
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<link rel="stylesheet" href="/styles.css"/>
<title><%= title %> | clearSKY</title>
<script>
  window.API_BASE = "<%= API_BASE %>";
</script>

===== front-end/views/partials/header.ejs =====
<div style="background:#e6e7ea;border:1px solid #c2c5c9;margin-bottom:1rem;padding:1rem">
</div>

===== front-end/views/partials/messageBox.ejs =====
<div style="margin-top:1.5rem;border:1px solid #c2c5c9">
  <div style="background:#e6e7ea;padding:0.4rem 0.6rem;font-weight:bold">
    Message area
  </div>
  <div style="height:100px"></div>
</div>

===== front-end/views/partials/navbar.ejs =====
<!-- views/partials/navbar.ejs -->
<nav class="navbar">
  <div class="navbar__brand">
    <a href="/" class="navbar__logo">clearSKY</a>
  </div>

  <% if (!user) { %>
    <!-- Guest nav -->
    <ul class="navbar__links">
      <li>
        <a href="/login"
           class="<%= currentUrl === '/login' ? 'active' : '' %>">
          Log in
        </a>
      </li>
    </ul>

  <% } else { %>
    <!-- Authenticated nav – role-aware -->
    <ul class="navbar__links">
      <% if (user.role === 'student') { %>
        <%- include('./nav-student', { currentUrl }) %>

      <% } else if (user.role === 'instructor') { %>
        <%- include('./nav-instructor', { currentUrl }) %>

      <% } else if (['institution',
                     'institution_representative',
                     'representative'].includes(user.role)) { %>
        <%- include('./nav-institution', { currentUrl }) %>

      <% } else { %>
        <li><a href="/">Home</a></li>
      <% } %>
    </ul>

    <div class="navbar__auth">
      <span class="navbar__user">Hi, <%= user.username %></span>
      <a href="/login" id="logout-button" class="button button--secondary">
        Log out
      </a>
    </div>
  <% } %>
</nav>

===== front-end/views/partials/nav-institution.ejs =====
<li><a class="<%= currentUrl.startsWith('/institution/register') ? 'active' : '' %>"
       href="/institution/register">Register</a></li>
<li><a class="<%= currentUrl.startsWith('/institution/purchase') ? 'active' : '' %>"
       href="/institution/purchase">Purchase</a></li>
<li><a class="<%= currentUrl.startsWith('/institution/user-management') ? 'active' : '' %>"
       href="/institution/user-management">Users</a></li>
<li><a class="<%= currentUrl.startsWith('/institution/statistics') ? 'active' : '' %>"
       href="/institution/statistics">Statistics</a></li>
       
===== front-end/views/partials/nav-instructor.ejs =====
<li><a class="<%= currentUrl.startsWith('/instructor/post-initial') ? 'active' : '' %>"
       href="/instructor/post-initial">Post initial</a></li>
<li><a class="<%= currentUrl.startsWith('/instructor/post-final') ? 'active' : '' %>"
       href="/instructor/post-final">Post final</a></li>
<li><a class="<%= currentUrl.startsWith('/instructor/review-list') ? 'active' : '' %>"
       href="/instructor/review-list">Review list</a></li>
<li><a class="<%= currentUrl.startsWith('/instructor/reply') ? 'active' : '' %>"
       href="/instructor/reply">Reply form</a></li>
<li><a class="<%= currentUrl.startsWith('/instructor/statistics') ? 'active' : '' %>"
       href="/instructor/statistics">Statistics</a></li>

===== front-end/views/partials/nav-student.ejs =====
<li><a class="<%= currentUrl.startsWith('/student/my-courses') ? 'active' : '' %>"
       href="/student/my-courses">My courses</a></li>
<li><a class="<%= currentUrl.startsWith('/student/request') ? 'active' : '' %>"
       href="/student/request">New review</a></li>
<li><a class="<%= currentUrl.startsWith('/student/status') ? 'active' : '' %>"
       href="/student/status">Review status</a></li>
<li><a class="<%= currentUrl.startsWith('/student/statistics') ? 'active' : '' %>"
       href="/student/statistics">Statistics</a></li>
<li><a class="<%= currentUrl.startsWith('/student/personal') ? 'active' : '' %>"
       href="/student/personal">Personal grades</a></li>

===== front-end/views/signup.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('partials/head', { title: 'Sign up' }) %>
</head>
<body>
  <%- include('partials/navbar') %>

  <main class="login-container">
    <fieldset>
      <legend>Create account</legend>

      <form id="signup-form" novalidate>
        <div class="form-group">
          <label>E-mail</label>
          <input name="email" type="email" required />
        </div>

        <div class="form-group">
          <label>Password</label>
          <input name="password" type="password" required />
        </div>

        <div class="form-group">
          <label>Role</label>
          <select name="role">
            <option value="student">Student</option>
            <option value="instructor">Instructor</option>
            <option value="institution_representative">
              Institution representative
            </option>
          </select>
        </div>

        <button class="button" type="submit">Sign up</button>
        <a class="button button--secondary" href="/login">Back to log-in</a>
      </form>
    </fieldset>
  </main>

  <script type="module" src="/js/auth/signup.js"></script>
</body>
</html>

===== front-end/views/student/dashboard.ejs =====
<!DOCTYPE html><html lang="en"><head>
  <%- include('../partials/head',{title}) %>
</head><body>
  <%- include('../partials/navbar',{user}) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h1>Student Dashboard</h1>
    <div class="dashboard-grid mt-2">
      <a href="/student/statistics" class="card button-link">1. View course statistics</a>
      <a href="/student/my-courses" class="card button-link">2. My courses</a>
      <a href="/student/request"    class="card button-link">3. Grade review request</a>
      <a href="/student/status"     class="card button-link">4. Review request status</a>
      <a href="/student/personal"   class="card button-link">5. View personal grades</a>
    </div>

  </main>
</body></html>

===== front-end/views/student/myCourses.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'My Courses' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Student: <%= user.username %></h2>

    <table>
      <thead>
        <tr>
          <th>Course Name</th>
          <th>Exam Period</th>
          <th>Grading Status</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <!-- Populated by JS -->
      </tbody>
    </table>

    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/student/my-courses.js"></script>
</body>
</html>

===== front-end/views/student/personal.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'View Personal Grades' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Student: <%= user.username %></h2>

    <table>
      <thead>
        <tr>
          <th>Declaration Period</th>
          <th>Course Name</th>
          <th>Grading Status</th>
          <th>Grade</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be injected by personal.js -->
      </tbody>
    </table>

    <%- include('../partials/messageBox') %>
  </main>

  <!-- Make sure this path matches where your bundler/static server serves it -->
  <script type="module" src="/js/student/personal.js"></script>
</body>
</html>

===== front-end/views/student/reviewRequest.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'New Review Request' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Student: <%= user.username %></h2>

    <table>
      <thead>
        <tr>
          <th>Course Name</th>
          <th>Exam Period</th>
          <th>Grading Status</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <!-- Populated by JS -->
      </tbody>
    </table>

    <div class="panel">
      <div class="panel-header">NEW REVIEW REQUEST</div>
      <form id="student-review-request-form">
        <div class="form-group">
          <label>Message to instructor</label>
          <textarea name="message" style="width:100%;height:120px;"
            placeholder="please review my grade..."></textarea>
        </div>
        <button class="button" type="submit" style="float:right;">Submit</button>
        <div style="clear:both;"></div>
      </form>
    </div>
  </main>

  <script type="module" src="/js/student/review-request.js"></script>
</body>
</html>

===== front-end/views/student/reviewStatus.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head', { title: 'Review Request Status' }) %>
</head>
<body>
  <%- include('../partials/navbar', { user }) %>
  <main class="container">
    <%- include('../partials/header') %>
    <h2>Student: <%= user.username %></h2>

    <table>
      <thead>
        <tr>
          <th>Course Name</th>
          <th>Exam Period</th>
          <th>Grading Status</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody>
        <!-- Populated by JS -->
      </tbody>
    </table>

    <div class="panel">
      <div class="panel-header">REVIEW REQUEST STATUS</div>
      <div class="form-group">
        <label>Message from instructor</label>
        <textarea readonly style="width:100%;height:100px;"></textarea>
      </div>
      <button class="button">Acknowledge</button>
    </div>
  </main>

  <script type="module" src="/js/student/review-status.js"></script>
</body>
</html>

===== front-end/views/student/statistics.ejs =====
<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('../partials/head',{ title: 'Course Statistics' }) %>
</head>
<body>
  <%- include('../partials/navbar',{ user }) %>
  <main class="container">
    <%- include('../partials/header') %>

    <div class="panel">
      <div class="panel-header" style="display:flex;justify-content:space-between;align-items:center;">
        <span>Available course statistics</span>
        <a href="/student/my-courses" class="button button--secondary">My Courses</a>
      </div>
      <table>
        <thead>
          <tr>
            <th>Course Name</th>
            <th>Exam Period</th>
            <th>Initial Submission</th>
            <th>Final Submission</th>
          </tr>
        </thead>
        <tbody>
          <!-- Populated by JS -->
        </tbody>
      </table>
    </div>

    <div id="stats-charts" class="grid-stats">
      <!-- JS will render charts here -->
    </div>

    <%- include('../partials/messageBox') %>
  </main>

  <script type="module" src="/js/student/statistics.js"></script>
</body>
</html>


Collecting backend Go code...
=============================

Processing directory: credits_service
----------------------------

===== credits_service/dbService/dbService.go =====
package dbService

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/jackc/pgx"
	"github.com/jackc/pgx/v5/pgxpool"
)

var Pool *pgxpool.Pool

func InitDB() {
	user := os.Getenv("DB_USER")
	password := os.Getenv("DB_PASSWORD")
	host := os.Getenv("DB_HOST")
	port := os.Getenv("DB_PORT")
	dbname := os.Getenv("DB_NAME")

	dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		user, password, host, port, dbname)

	var err error
	Pool, err = pgxpool.New(context.Background(), dsn)
	if err != nil {
		log.Fatal("Unable to connect to database:", err)
	}

	if err = Pool.Ping(context.Background()); err != nil {
		log.Fatal("Unable to ping the database:", err)
	}

	log.Println("Connected to PostgreSQL via pgxpool.")
}

func Diminish(inst_name string, credits int) (bool, error) {
	ctx := context.Background()

	// 1. Start transaction
	tx, err := Pool.Begin(ctx)
	if err != nil {
		log.Printf("[Diminish] Failed to begin transaction: %v", err)
		return false, err
	}
	defer tx.Rollback(ctx) // automatic rollback on error

	// 2. Lock and read current credits
	checkQuery := `SELECT credits FROM credits_inst WHERE name = $1 FOR UPDATE`
	var current_credits int
	err = tx.QueryRow(ctx, checkQuery, inst_name).Scan(&current_credits)
	if err != nil {
		if err == pgx.ErrNoRows {
			log.Printf("[Diminish] Institution not found: %s", inst_name)
			return false, fmt.Errorf("institution '%s' not found", inst_name)
		}
		log.Printf("[Diminish] Failed to check credits: %v", err)
		return false, err
	}
	log.Printf("[Diminish] Current credits for %s: %d", inst_name, current_credits)

	// 3. Check for sufficient credits
	if current_credits < credits {
		log.Printf("[Diminish] Not enough credits: has %d, needs %d", current_credits, credits)
		return false, fmt.Errorf("insufficient credits (current: %d)", current_credits)
	}

	// 4. Perform update
	updateQuery := `UPDATE credits_inst SET credits = credits - $1 WHERE name = $2`
	res, err := tx.Exec(ctx, updateQuery, credits, inst_name)
	if err != nil {
		log.Printf("[Diminish] Failed to decrement credits: %v", err)
		return false, err
	}

	rows := res.RowsAffected()
	log.Printf("[Diminish] Rows affected by update: %d", rows)
	if rows != 1 {
		return false, fmt.Errorf("unexpected number of rows affected: %d", rows)
	}

	// 5. Commit
	if err := tx.Commit(ctx); err != nil {
		log.Printf("[Diminish] Failed to commit transaction: %v", err)
		return false, err
	}

	log.Printf("[Diminish] Credits decremented successfully for %s", inst_name)
	return true, nil
}

func BuyCredits(inst_name string, credits int) (bool, error) {
	ctx := context.Background()

	tx, err := Pool.Begin(ctx)
	if err != nil {
		log.Printf("Failed to begin transaction: %v", err)
		return false, err
	}
	defer tx.Rollback(ctx) // Safely rollback if anything fails

	insertQuery := `UPDATE credits_inst SET credits = credits + $1 WHERE name = $2`

	_, err = tx.Exec(ctx, insertQuery, credits, inst_name)

	if err != nil {
		log.Printf("Failed to make the purchase: %v", err)
		return false, err
	}

	if err := tx.Commit(ctx); err != nil {
		log.Printf("Failed to commit transaction: %v", err)
		return false, err
	}

	return true, nil

}

func AvailableCredits(instName string) (int, error) {
	ctx := context.Background()

	const qry = `
        SELECT credits
        FROM credits_inst
        WHERE name = $1
    `
	var current int
	err := Pool.QueryRow(ctx, qry, instName).Scan(&current)
	if err != nil {
		if err == pgx.ErrNoRows {
			return 0, fmt.Errorf("institution %q not found", instName)
		}
		log.Printf("Failed to query available credits for %q: %v", instName, err)
		return 0, err
	}

	return current, nil
}

func NewInstitution(instName string, initialCredits int) (bool, error) {
	ctx := context.Background()

	tx, err := Pool.Begin(ctx)
	if err != nil {
		log.Printf("Failed to begin transaction: %v", err)
		return false, err
	}
	defer tx.Rollback(ctx) // Ensures rollback on failure

	const checkQuery = `SELECT 1 FROM credits_inst WHERE name = $1`
	var exists int
	err = tx.QueryRow(ctx, checkQuery, instName).Scan(&exists)
	if err == nil {
		log.Printf("Error checking institution existence: %v", err)
		return false, fmt.Errorf("institution %q already exists", instName)
	}

	const insertQuery = `INSERT INTO credits_inst (name, credits) VALUES ($1, $2)`
	_, err = tx.Exec(ctx, insertQuery, instName, initialCredits)
	if err != nil {
		log.Printf("Failed to insert new institution: %v", err)
		return false, err
	}

	if err := tx.Commit(ctx); err != nil {
		log.Printf("Failed to commit transaction: %v", err)
		return false, err
	}

	return true, nil
}

===== credits_service/handlers/addNewInst.go =====
package handlers

import (
	"encoding/json"

	"credits_service/dbService"

	amqp "github.com/rabbitmq/amqp091-go"
)

type AddInstitutionReq struct {
	Name string `json:"name"`
	// Credits int    `json:"credits"`
}

func AddInstitutionHandler(d amqp.Delivery, ch *amqp.Channel) {
	var req AddInstitutionReq
	var res Response

	defer d.Ack(false)
	Credits := 10
	// Parse request JSON
	if err := json.Unmarshal(d.Body, &req); err != nil {
		res.Status = "error"
		res.Message = "Invalid JSON in request"
		res.Err = nil
		publishReply(ch, d, res)
		return
	}

	success, err := dbService.NewInstitution(req.Name, Credits)
	if err != nil {
		res.Status = "error"
		res.Message = "Could not add institution"
		res.Err = err
		publishReply(ch, d, res)
		return
	}

	if success {
		res.Status = "OK"
		res.Message = "Institution added successfully"
		res.Err = nil
		publishReply(ch, d, res)
		return
	}
}

===== credits_service/handlers/availableHandler.go =====
package handlers

import (
	"encoding/json"
	"log"

	"credits_service/dbService"

	amqp "github.com/rabbitmq/amqp091-go"
)

type AvailableReq struct {
	Name string `json:"name"`
}

type AvailableResp struct {
	Status      string `json:"status"`            // "ok" or "error"
	Credits     int    `json:"credits,omitempty"` // only on success
	Message     string `json:"message"`           // human-readable
	ErrorDetail string `json:"error,omitempty"`   // optional error text
}

func AvailableHandler(d amqp.Delivery, ch *amqp.Channel) {
	var req AvailableReq
	log.Printf("We are inside the microservices for return available credits")
	if err := json.Unmarshal(d.Body, &req); err != nil {
		log.Printf("Invalid JSON in AvailableHandler: %v", err)
		sendAvailableReplyAndNack(ch, d, AvailableResp{
			Status:      "error",
			Message:     "Invalid JSON",
			ErrorDetail: err.Error(),
		}, false)
		return
	}

	credits, err := dbService.AvailableCredits(req.Name)
	if err != nil {
		log.Printf("DB error in AvailableHandler: %v", err)
		sendAvailableReplyAndNack(ch, d, AvailableResp{
			Status:      "error",
			Message:     "Could not fetch balance",
			ErrorDetail: err.Error(),
		}, true)
		return
	}

	res := AvailableResp{
		Status:  "ok",
		Credits: credits,
		Message: "Current balance",
	}

	if err := publishAvailableReply(ch, d, res); err != nil {
		log.Printf("Publish reply failed in AvailableHandler: %v", err)
		d.Nack(false, true)
		return
	}
	log.Printf(res.Status)
	log.Printf("Available credits %d", res.Credits)
	d.Ack(false)
}

// sendAvailableReplyAndNack publishes the response and nacks the message
func sendAvailableReplyAndNack(ch *amqp.Channel, d amqp.Delivery, res AvailableResp, requeue bool) {
	if err := publishAvailableReply(ch, d, res); err != nil {
		log.Printf("Failed to publish AvailableResp: %v", err)
	}
	d.Nack(false, requeue)
}

// publishAvailableReply serializes a response and publishes it to d.ReplyTo.
func publishAvailableReply(ch *amqp.Channel, d amqp.Delivery, res AvailableResp) error {
	if d.ReplyTo == "" {
		return nil
	}
	body, err := json.Marshal(res)
	if err != nil {
		return err
	}
	return ch.Publish(
		"",        // default exchange
		d.ReplyTo, // callback queue
		false, false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: d.CorrelationId,
			Body:          body,
		},
	)
}

===== credits_service/handlers/buyController.go =====
// handlers/buy_handler.go
package handlers

import (
	"encoding/json"
	"log"

	"credits_service/dbService"

	amqp "github.com/rabbitmq/amqp091-go"
)

// BuyReq is the payload for a purchase request
type BuyReq struct {
	Name   string `json:"name"`
	Amount int    `json:"amount"`
}

type BuyResponse struct {
	Status      string `json:"status"`          // "ok" or "error"
	Message     string `json:"message"`         // human-readable
	ErrorDetail string `json:"error,omitempty"` // optional, for debugging
}

func HandleBuy(d amqp.Delivery, ch *amqp.Channel) {
	var req BuyReq

	if err := json.Unmarshal(d.Body, &req); err != nil {
		log.Printf("Invalid JSON received: %v", err)
		sendBuyReplyAndNack(ch, d, BuyResponse{
			Status:      "error",
			Message:     "Invalid JSON format",
			ErrorDetail: err.Error(),
		}, false)
		return
	}

	success, err := dbService.BuyCredits(req.Name, req.Amount)
	if err != nil {
		log.Printf("DB error during BuyCredits: %v", err)
		sendBuyReplyAndNack(ch, d, BuyResponse{
			Status:      "error",
			Message:     "Could not process purchase",
			ErrorDetail: err.Error(),
		}, true)
		return
	}

	var res BuyResponse
	if success {
		res = BuyResponse{Status: "ok", Message: "Credits purchased successfully"}
	} else {
		res = BuyResponse{Status: "error", Message: "Unknown error occurred during purchase"}
	}

	if err := publishBuyReply(ch, d, res); err != nil {
		log.Printf("Failed to publish reply: %v", err)
		d.Nack(false, true)
		return
	}
	d.Ack(false)
}

func sendBuyReplyAndNack(ch *amqp.Channel, d amqp.Delivery, res BuyResponse, requeue bool) {
	if err := publishBuyReply(ch, d, res); err != nil {
		log.Printf("Failed to publish error response: %v", err)
	}
	d.Nack(false, requeue)
}

func publishBuyReply(ch *amqp.Channel, d amqp.Delivery, res BuyResponse) error {
	if d.ReplyTo == "" {
		return nil
	}

	body, err := json.Marshal(res)
	if err != nil {
		return err
	}

	return ch.Publish(
		"",        // default exchange
		d.ReplyTo, // routing key (callback queue)
		false,     // mandatory
		false,     // immediate
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: d.CorrelationId,
			Body:          body,
		},
	)
}

===== credits_service/handlers/SpendController.go =====
package handlers

import (
	"encoding/json"
	"log"

	"credits_service/dbService"

	amqp "github.com/rabbitmq/amqp091-go"
)

type SpendReq struct {
	Name   string `json:"name"`
	Amount int    `json:"amount"` // Capitalized & correct type
	// code int `json:"code"`
}

type Response struct {
	Status  string `json:"status"`  // "ok", "conflict", "error"
	Message string `json:"message"` // details for humans
	Err     error  `json:"err"`
}

func Spending(d amqp.Delivery, ch *amqp.Channel) {
	log.Printf("[Spending] Received message. CorrelationID=%s, ReplyTo=%s", d.CorrelationId, d.ReplyTo)

	var req SpendReq
	var res Response

	// Ensure the message is acknowledged at the end, no matter what.
	defer func() {
		if err := d.Ack(false); err != nil {
			log.Printf("[Spending] Failed to ack message: %v", err)
		}
	}()

	// 1. Parse JSON ---------------------------------------------------------
	if err := json.Unmarshal(d.Body, &req); err != nil {
		log.Printf("[Spending] JSON unmarshal error: %v | Body=%s", err, string(d.Body))
		res.Status = "error"
		res.Message = "Invalid JSON"
		res.Err = nil
		publishReply(ch, d, res)
		return
	}
	log.Printf("[Spending] Parsed request: %+v", req)

	// 2. Attempt to diminish credits ---------------------------------------
	isComplete, err := dbService.Diminish(req.Name, req.Amount)
	log.Printf("[Spending] dbService.Diminish(Name=%s, Amount=%d) => isComplete=%t, err=%v", req.Name, req.Amount, isComplete, err)

	if err != nil {
		res.Status = "error"
		res.Message = "Error in internal process or not enough credits"
		res.Err = err
		publishReply(ch, d, res)
		return
	}

	if isComplete {
		res.Status = "OK"
		res.Message = "Valid spent of your credits"
		res.Err = nil
		publishReply(ch, d, res)
		return
	}

	// If we reach here, it means credits were diminished but not fully consumed (business rule dependent)
	res.Status = "conflict"
	res.Message = "Partial credits spent; remaining balance exists"
	res.Err = nil
	publishReply(ch, d, res)
}

func publishReply(ch *amqp.Channel, d amqp.Delivery, res Response) {
	// fire-and-forget call; nothing to send back
	if d.ReplyTo == "" {
		log.Printf("[publishReply] ReplyTo empty; not sending any response. CorrelationID=%s", d.CorrelationId)
		return
	}

	body, errMarshal := json.Marshal(res)
	if errMarshal != nil {
		log.Printf("[publishReply] Failed to marshal response: %v | Response=%+v", errMarshal, res)
		return
	}

	log.Printf("[publishReply] Publishing reply. CorrelationID=%s, Body=%s", d.CorrelationId, string(body))

	if err := ch.Publish(
		"",        // default exchange because we address the queue directly
		d.ReplyTo, // queue the caller named
		false,     // mandatory
		false,     // immediate
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: d.CorrelationId,
			Body:          body,
		},
	); err != nil {
		log.Printf("[publishReply] Failed to publish reply: %v", err)
	}
}

===== credits_service/main.go =====
// main.go
package main

import (
	"credits_service/dbService"
	"credits_service/handlers"
	"log"
	"os"
	"os/signal"
	"syscall"

	"github.com/joho/godotenv"
	amqp "github.com/rabbitmq/amqp091-go"
)

func failOnErr(err error, msg string) {
	if err != nil {
		log.Fatalf("%s: %v", msg, err)
	}
}

func main() {
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found; relying on system enviroment variables")
	}

	dbService.InitDB()

	rmqURL := os.Getenv("RABBITMQ_URL")

	if rmqURL == "" {
		rmqURL = "amqp://guest:guest@localhost:5672/"
	}

	conn, err := amqp.Dial(rmqURL)
	failOnErr(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnErr(err, "Failed to open channel")
	defer ch.Close()

	exchange := "clearSky.events"
	keys := []string{
		"credits.spent",
		"credits.purchased",
		"credits.avail",
		"add.new",
	}

	err = ch.ExchangeDeclare(
		exchange,
		"direct",
		true,
		false,
		false,
		false,
		nil,
	)
	failOnErr(err, "Failed to declare exchange")

	q, err := ch.QueueDeclare(
		"credits_queue", // queue name
		true,            // durable
		false,           // delete when unused
		false,           // exclusive
		false,           // no-wait
		nil,             // args
	)
	failOnErr(err, "Failed to declare queue")

	for _, key := range keys { //creating 3 bind, 1 per routing key
		if err := ch.QueueBind(
			q.Name,
			key,
			exchange,
			false,
			nil,
		); err != nil {
			failOnErr(err, "Failed to bind queue to key "+key)
		}
	}

	err = ch.Qos(3, 0, false) // three message at a time
	failOnErr(err, "Failed to set QoS")

	msgs, err := ch.Consume(
		q.Name,
		"credits_consumer", // consumer tag
		false,              // auto-ack -> false (we ack manually)
		false,              // exclusive
		false,              // no-local
		false,              // no-wait
		nil,                // args
	)
	failOnErr(err, "Failed to register consumer")

	// ----------------------------------------------------------------------
	// 5. Graceful shutdown handling
	// ----------------------------------------------------------------------
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	const workers = 5

	log.Println("Waiting for credits messages")

	for i := 0; i < workers; i++ {
		go worker(i, msgs, ch)
	}
	log.Printf("%d workers are listening for messages…\n", workers)

	<-sigs
	log.Println("Shutting down")
}

func worker(id int, msgs <-chan amqp.Delivery, ch *amqp.Channel) {
	log.Printf("Worker %d ready", id)
	for d := range msgs {
		switch d.RoutingKey {
		case "credits.spent":
			handlers.Spending(d, ch)
		case "credits.purchased":
			handlers.HandleBuy(d, ch)
		case "credits.avail":
			handlers.AvailableHandler(d, ch)
		case "add.new":
			handlers.AddInstitutionHandler(d, ch)
		default:
			log.Printf("Worker %d: unknown key %q", id, d.RoutingKey)
			d.Nack(false, false)
		}
	}
}


Processing directory: final_grades
----------------------------


Processing directory: google_auth_service
----------------------------

===== google_auth_service/database/db.go =====
package database

import (
	"log"

	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

var DB *gorm.DB

func ConnectDatabase() {
	var err error
	DB, err = gorm.Open(sqlite.Open("users.db"), &gorm.Config{})
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	// Migrate the User model with student_id field
	DB.AutoMigrate(&User{})
}

===== google_auth_service/database/models.go =====
package database

import (
	"gorm.io/gorm"
)

type User struct {
	gorm.Model
	Email     string `gorm:"unique;not null"`
	Name      string
	Picture   string
	Provider  string `gorm:"default:'google'"`
	Role      string `gorm:"default:'institution_representative'"`
	StudentID string `gorm:"unique"`
}

===== google_auth_service/handlers/auth.go =====
package handlers

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"google_auth_service/database"
	"google_auth_service/rabbitmq"
	"google_auth_service/utils"
	"net/http"
	"os"
	"strconv"
	"time"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"
)

var (
	oauthConfig *oauth2.Config
	// Define specific allowed emails only - replace with your actual emails
	allowedEmails = map[string]bool{
		"dimitris.thiv@gmail.com":   true,
		"dimliakis2001@gmail.com":   true,
		"rostav55@gmail.com":        true,
		"anastasvasilis4@gmail.com": true,
	}
)

func init() {
	oauthConfig = &oauth2.Config{
		RedirectURL:  os.Getenv("GOOGLE_REDIRECT_URL"), // πχ: http://localhost:8086/auth/google/callback
		ClientID:     os.Getenv("GOOGLE_CLIENT_ID"),
		ClientSecret: os.Getenv("GOOGLE_CLIENT_SECRET"),
		Scopes:       []string{"https://www.googleapis.com/auth/userinfo.email", "https://www.googleapis.com/auth/userinfo.profile"},
		Endpoint:     google.Endpoint,
	}
}

// helper to validate role - default Google users to representative
func normalizeRole(r string) string {
	switch r {
	case "student", "instructor", "institution_representative":
		return r
	default:
		return "institution_representative" // Changed from "student" to "institution_representative"
	}
}

// generateStudentID creates a unique student ID for new student users
func generateStudentID() string {
	// Generate a simple numeric student ID based on timestamp and random component
	timestamp := time.Now().Unix()
	return fmt.Sprintf("STU%d", timestamp%1000000)
}

// Redirects user to Google's consent screen
func GoogleLoginHandler(w http.ResponseWriter, r *http.Request) {
	// allow client to pass desired role on first login
	role := normalizeRole(r.URL.Query().Get("role"))
	url := oauthConfig.AuthCodeURL(role, oauth2.AccessTypeOffline) // state carries role
	http.Redirect(w, r, url, http.StatusTemporaryRedirect)
}

// Helper function to check if email is allowed - simplified to use only hardcoded emails
func isEmailAllowed(email string) bool {
	return allowedEmails[email]
}

// Handles Google's callback and fetches user info
func GoogleCallbackHandler(w http.ResponseWriter, r *http.Request) {
	ctx := context.Background()
	code := r.URL.Query().Get("code")

	if code == "" {
		http.Error(w, "No code in request", http.StatusBadRequest)
		return
	}

	token, err := oauthConfig.Exchange(ctx, code)
	if err != nil {
		http.Error(w, "Failed to exchange token: "+err.Error(), http.StatusInternalServerError)
		return
	}

	client := oauthConfig.Client(ctx, token)
	resp, err := client.Get("https://www.googleapis.com/oauth2/v2/userinfo")
	if err != nil {
		http.Error(w, "Failed to get user info: "+err.Error(), http.StatusInternalServerError)
		return
	}
	defer resp.Body.Close()

	var userInfo map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&userInfo); err != nil {
		http.Error(w, "Failed to decode user info: "+err.Error(), http.StatusInternalServerError)
		return
	}

	email := userInfo["email"].(string)

	// Validate email is allowed
	if !isEmailAllowed(email) {
		http.Error(w, "Access denied: Your email is not authorized for this application", http.StatusForbidden)
		return
	}

	// derive role from state - default to institution_representative for Google users
	role := normalizeRole(r.URL.Query().Get("state"))
	if r.URL.Query().Get("state") == "" {
		role = "institution_representative"
	}

	name := userInfo["name"].(string)
	picture := userInfo["picture"].(string)

	// Find or create user in local database
	var user database.User
	result := database.DB.First(&user, "email = ?", email)

	var studentID string
	if result.Error != nil {
		// Create new user - no student_id for representatives
		user = database.User{
			Email:     email,
			Name:      name,
			Picture:   picture,
			Provider:  "google",
			Role:      role,
			StudentID: studentID, // Will be empty for representatives
		}
		database.DB.Create(&user)
	} else {
		// Update existing user
		user.Name = name
		user.Picture = picture
		if user.Role != role {
			user.Role = role
			// Only generate student_id if role is student
			if role == "student" && user.StudentID == "" {
				user.StudentID = generateStudentID()
			}
		}
		database.DB.Save(&user)
		// Only use student_id if user is a student
		if user.Role == "student" {
			studentID = user.StudentID
		}
	}

	// Generate JWT with student_id only for students
	userIDStr := strconv.Itoa(int(user.ID))
	jwtToken, err := utils.GenerateJWT(userIDStr, email, user.Role, studentID)
	if err != nil {
		http.Error(w, "Failed to generate JWT: "+err.Error(), http.StatusInternalServerError)
		return
	}

	// Set cookie with proper domain settings for localhost
	cookie := http.Cookie{
		Name:     "token",
		Value:    jwtToken,
		Path:     "/",
		Domain:   "",    // Empty domain for localhost
		HttpOnly: false, // Set to false so frontend can read it
		Secure:   false, // Set to true in production with HTTPS
		SameSite: http.SameSiteLaxMode,
		MaxAge:   86400, // 1 day
	}

	http.SetCookie(w, &cookie)

	rabbitmq.PublishLoginEvent(email)

	// Sync with User Management Service
	umsHost := os.Getenv("UMS_URL")
	if umsHost == "" {
		umsHost = "http://user_management_service:8082"
	}

	upsertPayload := map[string]interface{}{
		"username":   email, // Use email as username for Google users
		"role":       user.Role,
		"student_id": user.StudentID,
	}

	buf, _ := json.Marshal(upsertPayload)
	http.Post(umsHost+"/upsert", "application/json", bytes.NewBuffer(buf))

	// Redirect to frontend with Google login success parameter
	frontendURL := os.Getenv("FRONTEND_URL")
	if frontendURL == "" {
		frontendURL = "http://localhost:3000"
	}

	// Always redirect to frontend callback to handle session setup
	http.Redirect(w, r, frontendURL+"/auth/google/callback?google_login=success&role="+user.Role+"&email="+email, http.StatusTemporaryRedirect)
}

// LogoutHandler διαγράφει το token cookie
func LogoutHandler(w http.ResponseWriter, r *http.Request) {
	cookie := http.Cookie{
		Name:     "token",
		Value:    "",
		Path:     "/",
		MaxAge:   -1, // Expire immediately
		HttpOnly: true,
		Secure:   false, // Set to true in production with HTTPS
		SameSite: http.SameSiteLaxMode,
	}

	http.SetCookie(w, &cookie)

	w.Header().Set("Content-Type", "text/html")
	w.Write([]byte("<h1>Logout successful!</h1>"))
}

===== google_auth_service/main.go =====
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"google_auth_service/database"
	"google_auth_service/handlers"
	"google_auth_service/middlewares"
	"google_auth_service/rabbitmq"

	"github.com/joho/godotenv"
)

func main() {
	// Load .env file if it exists
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found, using system environment variables")
	}

	// Validate required environment variables
	requiredEnvVars := []string{
		"GOOGLE_CLIENT_ID",
		"GOOGLE_CLIENT_SECRET",
		"GOOGLE_REDIRECT_URL",
		"JWT_SECRET",
	}

	for _, envVar := range requiredEnvVars {
		if os.Getenv(envVar) == "" {
			log.Fatalf("Required environment variable %s is not set", envVar)
		}
	}

	// Log loaded configuration (without secrets)
	log.Printf("Google Client ID: %s", os.Getenv("GOOGLE_CLIENT_ID"))
	log.Printf("Redirect URL: %s", os.Getenv("GOOGLE_REDIRECT_URL"))

	database.ConnectDatabase()
	rabbitmq.Connect()
	rabbitmq.StartGoogleAuthConsumer()

	port := "8086"
	if os.Getenv("PORT") != "" {
		port = os.Getenv("PORT")
	}

	http.HandleFunc("/auth/google/login", handlers.GoogleLoginHandler)
	http.HandleFunc("/auth/google/callback", handlers.GoogleCallbackHandler)
	http.HandleFunc("/auth/logout", handlers.LogoutHandler)
	protected := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("Welcome to the protected route!"))
	})

	http.Handle("/protected", middlewares.AuthMiddleware(protected))

	fmt.Printf("Starting google_auth_service on port %s...\n", port)
	fmt.Printf("Google OAuth redirect URL: %s\n", os.Getenv("GOOGLE_REDIRECT_URL"))
	err := http.ListenAndServe(":"+port, nil)
	if err != nil {
		log.Fatalf("Server failed to start: %v", err)
	}
}

===== google_auth_service/middlewares/auth.go =====
package middlewares

import (
	"context"
	"google_auth_service/utils"
	"net/http"
)

func AuthMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		cookie, err := r.Cookie("token")
		if err != nil {
			http.Error(w, "Unauthorized - no token", http.StatusUnauthorized)
			return
		}

		claims, err := utils.VerifyJWT(cookie.Value)
		if err != nil {
			http.Error(w, "Unauthorized - invalid token", http.StatusUnauthorized)
			return
		}

		// Add claims to context for handlers to use
		ctx := context.WithValue(r.Context(), "claims", claims)
		ctx = context.WithValue(ctx, "user_id", claims.UserID)
		ctx = context.WithValue(ctx, "email", claims.Email)
		ctx = context.WithValue(ctx, "role", claims.Role)
		ctx = context.WithValue(ctx, "student_id", claims.StudentID)
		r = r.WithContext(ctx)

		next.ServeHTTP(w, r)
	})
}

===== google_auth_service/rabbitmq/consumer.go =====
package rabbitmq

import (
	"context"
	"encoding/json"
	"google_auth_service/database"
	"google_auth_service/utils"
	"log"
	"net/http"
	"os"
	"strconv"

	"github.com/google/uuid"
	amqp "github.com/rabbitmq/amqp091-go"
	"golang.org/x/oauth2/google"
)

type GoogleAuthRequest struct {
	Type  string `json:"type"`
	Token string `json:"token"`
	Role  string `json:"role,omitempty"`
}

type GoogleAuthResponse struct {
	Status    string `json:"status"`
	Message   string `json:"message,omitempty"`
	Token     string `json:"token,omitempty"`
	Email     string `json:"email,omitempty"`
	Role      string `json:"role,omitempty"`
	StudentID string `json:"student_id,omitempty"`
}

var allowedEmailsConsumer = map[string]bool{
	"dimitris.thiv@gmail.com":   true,
	"dimliakis2001@gmail.com":   true,
	"rostav55@gmail.com":        true,
	"anastasvasilis4@gmail.com": true,
}

func StartGoogleAuthConsumer() {
	url := os.Getenv("RABBITMQ_URL")
	if url == "" {
		url = "amqp://guest:guest@rabbitmq:5672/"
	}
	conn, err := amqp.Dial(url)
	if err != nil {
		log.Fatal("RabbitMQ connection failed:", err)
	}
	ch, err := conn.Channel()
	if err != nil {
		log.Fatal("RabbitMQ channel failed:", err)
	}

	// Declare exchange
	err = ch.ExchangeDeclare("clearSky.events", "direct", true, false, false, false, nil)
	if err != nil {
		log.Fatal("Exchange declare failed:", err)
	}

	queue := "google_auth.request"
	_, err = ch.QueueDeclare(queue, true, false, false, false, nil)
	if err != nil {
		log.Fatal("Queue declare failed:", err)
	}

	// Bind to the correct routing key
	err = ch.QueueBind(queue, "auth.login.google", "clearSky.events", false, nil)
	if err != nil {
		log.Fatal("Queue bind failed:", err)
	}

	msgs, err := ch.Consume(queue, "", false, false, false, false, nil)
	if err != nil {
		log.Fatal("Consume failed:", err)
	}

	go func() {
		for d := range msgs {
			var req GoogleAuthRequest
			if err := json.Unmarshal(d.Body, &req); err != nil {
				continue
			}

			resp := GoogleAuthResponse{}
			email, err := verifyGoogleToken(req.Token)
			if err != nil {
				resp.Status = "error"
				resp.Message = "Invalid Google token"
			} else if !isEmailAllowed(email) {
				resp.Status = "error"
				resp.Message = "Access denied: Email not authorized"
			} else {
				// Find or create user with proper role handling
				var user database.User
				result := database.DB.First(&user, "email = ?", email)

				role := req.Role
				if role == "" {
					role = "institution_representative" // Default for Google users
				}

				var studentID string
				if result.Error != nil {
					// Create new user - only assign student_id if role is student
					if role == "student" {
						studentID = generateStudentID()
					}
					user = database.User{
						Email:     email,
						Role:      role,
						StudentID: studentID,
						Provider:  "google",
					}
					database.DB.Create(&user)
				} else {
					// Only use student_id for students
					if user.Role == "student" {
						studentID = user.StudentID
						if studentID == "" && role == "student" {
							studentID = generateStudentID()
							user.StudentID = studentID
							database.DB.Save(&user)
						}
					}
				}

				userIDStr := strconv.Itoa(int(user.ID))
				token, _ := utils.GenerateJWT(userIDStr, email, role, studentID)
				resp.Status = "ok"
				resp.Token = token
				resp.Email = email
				resp.Role = role
				resp.StudentID = studentID
			}

			body, _ := json.Marshal(resp)
			if d.ReplyTo != "" && d.CorrelationId != "" {
				ch.Publish(
					"", d.ReplyTo, false, false,
					amqp.Publishing{
						ContentType:   "application/json",
						CorrelationId: d.CorrelationId,
						Body:          body,
					},
				)
			}
			d.Ack(false)
		}
	}()
}

// generateStudentID creates a unique student ID
func generateStudentID() string {
	return "STU" + uuid.New().String()[:8]
}

// Helper to verify Google token and extract email
func verifyGoogleToken(idToken string) (string, error) {
	ctx := context.Background()
	oauth2Service, err := google.DefaultClient(ctx, "https://www.googleapis.com/auth/userinfo.email")
	if err != nil {
		return "", err
	}
	resp, err := oauth2Service.Get("https://www.googleapis.com/oauth2/v3/tokeninfo?id_token=" + idToken)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	var tokenInfo struct {
		Email string `json:"email"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&tokenInfo); err != nil {
		return "", err
	}
	if tokenInfo.Email == "" {
		return "", http.ErrNoCookie
	}
	return tokenInfo.Email, nil
}

// Helper function to check if email is allowed
func isEmailAllowed(email string) bool {
	return allowedEmailsConsumer[email]
}

===== google_auth_service/rabbitmq/publisher.go =====
package rabbitmq

import (
	"log"
	"os"

	amqp "github.com/rabbitmq/amqp091-go"
)

var conn *amqp.Connection
var ch *amqp.Channel

func Connect() {
	var err error
	conn, err = amqp.Dial(os.Getenv("RABBITMQ_URL"))
	if err != nil {
		log.Println("⚠️ Could not connect to RabbitMQ:", err)
		return
	}

	ch, err = conn.Channel()
	if err != nil {
		log.Println("⚠️ Could not open RabbitMQ channel:", err)
		return
	}

	if err := ch.ExchangeDeclare(
		"clearsky.events", "topic", true, false, false, false, nil,
	); err != nil {
		log.Fatalf("Declare clearsky.events: %v", err)
	}

	queue := "google_auth.request"
	if _, err := ch.QueueDeclare(queue, true, false, false, false, nil); err != nil {
		log.Fatalf("QueueDeclare %s: %v", queue, err)
	}
	if err := ch.QueueBind(
		queue, "user.login.google", "clearsky.events", false, nil,
	); err != nil {
		log.Fatalf("QueueBind user.login.google: %v", err)
	}
}

func PublishLoginEvent(email string) {
	if ch == nil {
		log.Println("⚠️ RabbitMQ channel not initialized, skipping publish")
		return
	}

	body := `{"event":"user_logged_in","email":"` + email + `"}`

	err := ch.Publish(
		"clearsky.events", // exchange
		"",                // routing key (fanout)
		false,
		false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        []byte(body),
		},
	)
	if err != nil {
		log.Println("⚠️ Failed to publish message:", err)
	} else {
		log.Printf("📤 Published user_logged_in for %s\n", email)
	}
}

===== google_auth_service/utils/jwt.go =====
package utils

import (
	"errors"
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

var jwtKey = []byte(os.Getenv("JWT_SECRET"))

type Claims struct {
	UserID    string `json:"user_id"`
	Username  string `json:"username,omitempty"`
	Email     string `json:"email"`
	Role      string `json:"role"`
	StudentID string `json:"student_id,omitempty"` // Add student_id field
	jwt.RegisteredClaims
}

func GenerateJWT(userID, email, role, studentID string) (string, error) {
	expirationTime := time.Now().Add(24 * time.Hour)

	claims := &Claims{
		UserID:    userID,
		Username:  email, // Use email as username for Google users
		Email:     email,
		Role:      role,
		StudentID: studentID, // Include student_id in JWT
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(jwtKey)
}

func VerifyJWT(tokenString string) (*Claims, error) {
	claims := &Claims{}

	token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})
	if err != nil || !token.Valid {
		return nil, errors.New("invalid token")
	}
	return claims, nil
}


Processing directory: initial_grades
----------------------------


Processing directory: instructor_review_reply_service
----------------------------

===== instructor_review_reply_service/controllers/dataStructs.go =====
package controllers

import "time"

type ReviewSummary struct {
	StudentID       string    `json:"student_id"`
	CourseID        string    `json:"course_id"`
	ReviewCreatedAt time.Time `json:"review_created_at"`
}

type ReviewStruct struct {
	Student_id               string     `json:"student_id"`
	Course_id                string     `json:"course_id"`
	Exam_period              string     `json:"exam_period"`
	Student_message          string     `json:"student_message"`
	Status                   string     `json:"status"`
	Instructor_reply_message *string    `json:"instructor_reply_message"`
	Instructor_action        *string    `json:"instructor_action"`
	Review_created_at        time.Time  `json:"review_created_at"`
	Reviewed_at              *time.Time `json:"reviewed_at"`
}

type InstructorReply struct {
	InstructorReply  string `json:"instructor_reply_message" binding:"required"`
	InstructorAction string `json:"instructor_action" binding:"required"`
}

===== instructor_review_reply_service/controllers/GetRequestInfo.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"instructor_review_reply_service/db"
)

func GetRequestInfo(body map[string]interface{}) (string, error) {

	// input send by orchestrator in json form like:
	//{
	//"body": {
	//  "course_id": "101",
	//  "exam_period": "spring 2025",
	//  "user_id": "42"
	//}

	// get data from json
	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing course_id")
	}

	userID, ok := body["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing user_id")
	}

	examPeriod, ok := body["exam_period"].(string)
	if !ok {
		return "", fmt.Errorf("missing exam_period")
	}

	// search db using student_id & course_id & exam_period.
	query := `
		SELECT student_id, course_id, exam_period, student_message, review_created_at 
		FROM reviews 
		WHERE student_id = $1 AND course_id = $2 AND exam_period = $3`

	row := db.DB.QueryRow(query, userID, courseID, examPeriod)

	var review ReviewStruct
	err := row.Scan(
		&review.Student_id,
		&review.Course_id,
		&review.Exam_period,
		&review.Student_message,
		&review.Review_created_at,
	)
	if err != nil {
		emptyResponse := map[string]interface{}{
			"message": "No review found for the given input.",
		}
		respBytes, _ := json.Marshal(emptyResponse)
		return string(respBytes), nil
	}
	resBytes, _ := json.Marshal(review)
	return string(resBytes), nil
}

/* func GetRequestInfo(c *gin.Context) {
	reviewIDStr := c.Param("review_id")
	reviewID, err := strconv.Atoi(reviewIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid review ID"})
		return
	}
	query := `
			SELECT
				student_id, course_id, student_message, status, instructor_reply_message,
				instructor_action, review_created_at, reviewed_at
			FROM reviews
			WHERE review_id = $1
		`

	row := db.DB.QueryRow(query, reviewID)

	var review ReviewStruct

	err = row.Scan(
		&review.Student_id,
		&review.Course_id,
		&review.Student_message,
		&review.Status,
		&review.Instructor_reply_message,
		&review.Instructor_action,
		&review.Review_created_at,
		&review.Reviewed_at,
	)
	log.Println("Scan error:", err)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Review not found"})
		return
	}

	c.JSON(http.StatusOK, review)

} */

===== instructor_review_reply_service/controllers/GetReviewReqeustList.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"instructor_review_reply_service/db"
)

func GetReviewReqeustList(body map[string]interface{}) (string, error) {
	// input send by orchestrator in json form like:
	// {
	//   "body": {
	//     "course_id": "101"
	//	 }
	// }

	// extract data from input.
	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing course_id")
	}
	query := `
		SELECT student_id, course_id, review_created_at 
		FROM reviews 
		WHERE course_id = $1 AND status = 'pending'
		`
	rows, err := db.DB.Query(query, courseID)
	if err != nil {
		return "", fmt.Errorf("query error: %v", err)
	}
	defer rows.Close()

	var requestlist []ReviewSummary
	for rows.Next() {
		var summary ReviewSummary
		err := rows.Scan(&summary.StudentID, &summary.CourseID, &summary.ReviewCreatedAt)
		if err != nil {
			fmt.Println("Scan error:", err)
			continue
		}
		requestlist = append(requestlist, summary)
	}
	if len(requestlist) == 0 {
		emptyResponse := map[string]interface{}{
			"message": "No pending review requests found.",
			"data":    []ReviewSummary{},
		}
		respBytes, _ := json.Marshal(emptyResponse)
		return string(respBytes), nil
	}

	successResponse := map[string]interface{}{
		"message": "Pending review requests retrieved successfully.",
		"data":    requestlist,
	}
	respBytes, err := json.Marshal(successResponse)
	if err != nil {
		return "", fmt.Errorf("failed to marshal response: %v", err)
	}

	return string(respBytes), nil
}

/* func GetReviewReqeustList(c *gin.Context) {

	query := `SELECT student_id, course_id, review_created_at FROM reviews WHERE status = 'pending'`
	rows, err := db.DB.Query(query)
	if err != nil {
		log.Println("Query error:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		return
	}
	defer rows.Close()

	var requestlist []ReviewSummary
	for rows.Next() {
		var summary ReviewSummary
		err := rows.Scan(&summary.StudentID, &summary.CourseID, &summary.ReviewCreatedAt)
		if err != nil {
			log.Println("Scan error:", err)
			continue
		}
		requestlist = append(requestlist, summary)
	}
	if len(requestlist) == 0 {
		c.JSON(http.StatusOK, gin.H{"message": "No pending review requests"})
	} else {
		c.JSON(http.StatusOK, requestlist)
	}
}
*/

===== instructor_review_reply_service/controllers/insertStudentRequest.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"instructor_review_reply_service/db"
)

func InsertStudentRequest(body map[string]interface{}) (string, error) {

	// input send by orchestrator in json form like:
	// {
	//   "body": {
	//     "exam_period": "spring 2025",
	//     "course_id": "101",
	//     "user_id": 42,
	//     "student_message": "Please recheck my assignment."
	//   }
	// }

	// extract data from input.
	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid course_id")
	}

	examPeriod, ok := body["exam_period"].(string)
	if !ok {
		return "", fmt.Errorf("missing exam_period")
	}

	userID, ok := body["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid user_id")
	}

	studentMessage, ok := body["student_message"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid student_message")
	}

	// add review to db
	query := `INSERT INTO reviews (student_id, course_id, exam_period, student_message) VALUES ($1, $2, $3, $4)`
	result, err := db.DB.Exec(query, userID, courseID, examPeriod, studentMessage)
	if err != nil {
		fmt.Println("Insert error:", err)
		return "", fmt.Errorf("failed to insert review")
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil || rowsAffected == 0 {
		failResponse := map[string]interface{}{
			"error":   "Insert failed",
			"message": "Failed to insert review on student end.",
		}
		failRespBytes, _ := json.Marshal(failResponse)
		return string(failRespBytes), nil
	}

	// Return success response
	response := map[string]interface{}{
		"message": "Review request submitted successfully on instructor end.",
	}
	respBytes, _ := json.Marshal(response)
	return string(respBytes), nil
}

===== instructor_review_reply_service/controllers/PostReply.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"instructor_review_reply_service/db"
)

func PostReply(body map[string]interface{}) (string, error) {

	// input send by orchestrator in json form like:
	//{
	//	"body": {
	//	  "course_id": "101",
	//	  "exam_period": "spring 2025",
	//	  "user_id": "42"
	//	  "instructor_reply_message": "NO WAY!"
	//	  "instructor_action": "Denied"
	//	}
	//}

	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing course_id")
	}

	userID, ok := body["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing user_id")
	}

	examPeriod, ok := body["exam_period"].(string)
	if !ok {
		return "", fmt.Errorf("missing exam_period")
	}

	instructorReply, ok := body["instructor_reply_message"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid instructor_reply_message")
	}

	instructorAction, ok := body["instructor_action"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid instructor_action")
	}

	query := `
		UPDATE reviews 
		SET instructor_reply_message = $1,
			instructor_action = $2,
			status = 'reviewed',
			reviewed_at = CURRENT_TIMESTAMP
		WHERE student_id = $3 AND course_id = $4 AND exam_period = $5	
	`

	result, err := db.DB.Exec(query, instructorReply, instructorAction, userID, courseID, examPeriod)
	if err != nil {
		return "", fmt.Errorf("failed to update review: %v", err)
	}
	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		failResponse := map[string]interface{}{
			"message": "Failed to update instructor response in database on student end.",
		}
		failRespBytes, _ := json.Marshal(failResponse)
		return string(failRespBytes), nil
	}

	response := map[string]interface{}{
		"message": "Instructor response updated successfully on instructor end.",
	}
	respBytes, _ := json.Marshal(response)
	return string(respBytes), nil

}

/* func PostReply(c *gin.Context) {
	reviewIDStr := c.Param("review_id")
	reviewID, err := strconv.Atoi(reviewIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid review ID"})
		return
	}

	// Ginstructor reply from request body
	var reqBody InstructorReply
	if err := c.ShouldBindJSON(&reqBody); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON body"})
		return
	}
	query := `
		UPDATE reviews
		SET instructor_reply_message = $1,
			instructor_action = $2,
			status = 'reviewed',
			reviewed_at = CURRENT_TIMESTAMP
		WHERE review_id = $3
	`
	_, err = db.DB.Exec(query, reqBody.InstructorReply, reqBody.InstructorAction, reviewID)
	if err != nil {
		log.Println("Update error:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update review"})
		return
	}
	c.JSON(http.StatusOK, gin.H{
		"message":                  "Reply submitted successfully.",
		"review_id":                reviewID,
		"instructor_reply_message": reqBody.InstructorReply,
		"instructor_action":        reqBody.InstructorAction,
	})
}
*/

===== instructor_review_reply_service/db/db_init.go =====
package db

import (
	"database/sql"
	"fmt"

	_ "github.com/lib/pq"
)

var DB *sql.DB

func InitDB() error {

	// CONNECT TO REVIEWS DB
	// URL for docker connection
	//reviewsdbURL := "postgres://postgres:root@db:5432/reviewsdbinst?sslmode=disable"
	reviewsdbURL := "postgres://postgres:root@instructor_db:5432/reviewsdbinst?sslmode=disable"

	// URL for local connection
	//reviewsdbURL := "postgres://postgres:root@localhost:5432/reviewsinst?sslmode=disable"

	var err error
	DB, err = sql.Open("postgres", reviewsdbURL)
	if err != nil {
		fmt.Println("DB open error:", err)
		return err
	}
	err = DB.Ping()
	if err != nil {
		fmt.Println("DB ping error:", err)
		return err
	}
	fmt.Println("DB connection established.")
	return nil
}

func CloseDB() {
	DB.Close()
}

===== instructor_review_reply_service/main.go =====
// instructor_review_reply_service
package main

import (
	"fmt"
	"instructor_review_reply_service/db"
	"instructor_review_reply_service/mq"
	"time"

	_ "github.com/lib/pq"
)

func main() {

	for i := 0; i < 15; i++ {
		err := mq.InitRabbitMQ()
		if err == nil {
			break
		}
		fmt.Printf("Waiting for RabbitMQ... (%d/15)\n", i+1)
		time.Sleep(3 * time.Second)
		if i == 14 {
			panic("Could not connect to RabbitMQ after 15 tries")
		}
	}
	defer mq.Mqconn.Close()
	defer mq.Mqch.Close()

	for i := 0; i < 5; i++ {
		err := db.InitDB()
		if err == nil {
			break
		}
		fmt.Printf("Waiting for DB... (%d/5)\n", i+1)
		time.Sleep(3 * time.Second)
		if i == 4 {
			panic("Could not connect to DB after 5 tries")
		}
	}
	defer db.CloseDB()

	mq.StartConsumer()

	fmt.Println("Instructor Service started and waiting for RabbitMQ messages...")
	select {}
}

===== instructor_review_reply_service/mq/consumer.go =====
package mq

import (
	"fmt"

	"instructor_review_reply_service/routes"

	"github.com/streadway/amqp"
)

// function to handle errors
func errorHandling(err error, msg string) {
	if err != nil {
		fmt.Printf("%s: %s\n", msg, err)
	}
}

func StartConsumer() {

	// keys for instructor events
	exchangeKey := "clearSky.events"
	routingKeysinstructor := []string{
		"instructor.postResponse",
		"instructor.getRequestsList",
		"instructor.getRequestInfo",
		"instructor.insertStudentRequest",
	}

	// declare direct exchange for event routing
	err := Mqch.ExchangeDeclare(
		exchangeKey, // name
		"direct",    // type
		true,        // durable
		false,       // auto-deleted
		false,       // internal
		false,       // no-wait
		nil,         // arguments
	)
	errorHandling(err, "Failed to declare exchange")

	// declare a durable queue
	queue, err := Mqch.QueueDeclare(
		"instructor_queue", // queue name
		true,               // durable
		false,              // delete when unused
		false,              // not exclusive
		false,              // no-wait
		nil,
	)
	errorHandling(err, "Failed to declare queue")

	// bind the queue to each routing key
	for _, key := range routingKeysinstructor {
		err := Mqch.QueueBind(
			queue.Name,
			key,
			exchangeKey,
			false,
			nil,
		)
		errorHandling(err, "Failed to bind queue with key "+key)
	}

	// start consuming messages
	msgs, err := Mqch.Consume(
		queue.Name,
		"instructor_consumer", // consumer tag
		false,                 // manual acks!
		false,                 // not exclusive
		false,                 // no-local (not supported)
		false,                 // no-wait
		nil,
	)
	errorHandling(err, "Failed to register consumer")

	fmt.Println("Consumer Declared.")
	fmt.Printf(" [*] Waiting for messages on: %s\n", queue.Name)

	go func() {
		for d := range msgs {
			fmt.Printf("Received message: %s", d.Body)

			response, err := routes.Routing(d.RoutingKey, d.Body)
			if err != nil {
				fmt.Printf("Error processing message for routing key %s: %v", d.RoutingKey, err)
				response = fmt.Sprintf(`{"error": "%s"}`, err.Error())
			}

			fmt.Printf("Reply: %s\n", response)

			err = Mqch.Publish(
				"",        // default exchange for reply
				d.ReplyTo, // reply queue
				false,
				false,
				amqp.Publishing{
					ContentType:   "application/json",
					CorrelationId: d.CorrelationId,
					Body:          []byte(response),
				},
			)

			if err != nil {
				fmt.Println("Reply failed.")
				fmt.Println(err)
				d.Nack(false, true) // requeue on publish failure
			} else {
				fmt.Printf("Sent reply to %s\n", d.ReplyTo)
				d.Ack(false)
			}
		}
	}()
}

===== instructor_review_reply_service/mq/initmq.go =====
package mq

import (
	"fmt"

	"github.com/streadway/amqp"
)

var Mqconn *amqp.Connection
var Mqch *amqp.Channel

func InitRabbitMQ() error {
	var err error
	// FOR LOCAL TESTING ONLY.
	//Mqconn, err = amqp.Dial("amqp://guest:guest@localhost:5672/")
	Mqconn, err = amqp.Dial("amqp://guest:guest@rabbitmq:5672/")
	if err != nil {
		fmt.Println("Failed to connect to RabbitMQ:", err)
		return err
	}
	fmt.Println("RabbitMQ connection initialized.")

	Mqch, err = Mqconn.Channel()
	if err != nil {
		fmt.Println("Failed to open a channel:", err)
		return err
	}
	fmt.Println("RabbitMQ Channel initialized.")
	return nil
}

===== instructor_review_reply_service/routes/routes.go =====
package routes

/* import (
	"instructor_review_reply_service/controllers"

	"github.com/gin-gonic/gin"
)

func PostReply(router *gin.Engine) {
	router.POST("/review_request/:review_id", controllers.PostReply)
}

func GetReviewReqeustList(router *gin.Engine) {
	router.GET("/allrequests", controllers.GetReviewReqeustList)
}

func GetRequestInfo(router *gin.Engine) {
	router.GET("/review_info/:review_id", controllers.GetRequestInfo)
}
*/

import (
	"encoding/json"
	"fmt"
	"instructor_review_reply_service/controllers"
)

type Message struct {
	Params map[string]string      `json:"params"`
	Body   map[string]interface{} `json:"body"`
}

func Routing(routingKey string, messageBody []byte) (string, error) {
	var msg Message
	err := json.Unmarshal(messageBody, &msg)
	if err != nil {
		return "", fmt.Errorf("failed to parse message: %w", err)
	}

	switch routingKey {
	case "instructor.postResponse":
		return controllers.PostReply(msg.Body)

	case "instructor.getRequestsList":
		return controllers.GetReviewReqeustList(msg.Body)

	case "instructor.getRequestInfo":
		return controllers.GetRequestInfo(msg.Body)

	case "instructor.insertStudentRequest":
		return controllers.InsertStudentRequest(msg.Body)

	default:
		return "", fmt.Errorf("unknown routing key: %s", routingKey)
	}
}


Processing directory: orchestrator
----------------------------

===== orchestrator/cmd/orchestrator/main.go =====
package main

import (
	"log"

	"orchestrator/internal/config"
	"orchestrator/internal/rabbitmq"
	"orchestrator/internal/routes"
)

func main() {
	// Load config (auto via init)
	log.Println("Starting Orchestrator...")

	// Connect to RabbitMQ
	conn, ch := rabbitmq.Connect()
	defer conn.Close()
	defer ch.Close()

	// Setup exchanges, queues, bindings
	if err := rabbitmq.SetupMessaging(ch); err != nil {
		log.Fatalf("SetupMessaging failed: %v", err)
	}

	// Start consuming
	if err := rabbitmq.StartOrchestratorConsumer(ch); err != nil {
		log.Fatalf("Consumer failed: %v", err)
	}

	log.Printf("Orchestrator listening on exchange '%s', queue '%s'...", config.Cfg.Exchange.Name, config.Cfg.Queue.Name)

	router := routes.SetupRouter(ch)

	// 6. Start Gin (blocks here)
	log.Println("HTTP server running on :8080")
	if err := router.Run(":8080"); err != nil {
		log.Fatalf("Gin failed: %v", err)
	}

	select {} // block forever
}

===== orchestrator/internal/config/config.go =====
package config

import (
	"io/ioutil"
	"os"

	"gopkg.in/yaml.v3"
)

type Config struct {
	RabbitMQ struct {
		URL string `yaml:"url"`
	} `yaml:"rabbitmq"`
	Exchange struct {
		Name string `yaml:"name"`
		Type string `yaml:"type"`
	} `yaml:"exchange"`
	Queue struct {
		Name string `yaml:"name"`
		DLX  string `yaml:"dlx"`
	} `yaml:"queue"`
	Bindings []string `yaml:"bindings"`
}

var Cfg Config

func LoadConfig(path string) error {
	data, err := ioutil.ReadFile(path)
	if err != nil {
		return err
	}
	return yaml.Unmarshal(data, &Cfg)
}

func init() {
	cfgPath := os.Getenv("CONFIG_PATH")
	if cfgPath == "" {
		cfgPath = "configs/config.dev.yaml"
	}
	if err := LoadConfig(cfgPath); err != nil {
		panic(err)
	}
}

===== orchestrator/internal/handlers/credits.go =====
package handlers

import (
	"context"
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	amqp "github.com/rabbitmq/amqp091-go"
)

type PurchaseRequest struct {
	Name   string `json:"name" binding:"required"`
	Amount int    `json:"amount" binding:"required,gt=0"`
}

type PurchaseResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
	Error   string `json:"error,omitempty"`
}

type SpendReq struct {
	Name   string `json:"name"`
	Amount int    `json:"amount"` // Capitalized & correct type
	// code int `json:"code"`
}

type SpendResponse struct {
	Status  string `json:"status"`  // "ok", "conflict", "error"
	Message string `json:"message"` // details for humans
	Err     error  `json:"err"`
	Error   string `json:"error,omitempty"`
}

type AvailableReq struct {
	Name string `json:"name" binding:"required"`
}

type AvailableResp struct {
	Status      string `json:"status"`            // "ok" or "error"
	Credits     int    `json:"credits,omitempty"` // only on success
	Message     string `json:"message"`           // human-readable
	ErrorDetail string `json:"error,omitempty"`   // optional error text
}

func HandleCreditsAvail(c *gin.Context, ch *amqp.Channel) {
	log.Printf("We made the API CALL")
	var req AvailableReq
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, AvailableResp{
			Status:      "error",
			ErrorDetail: err.Error(),
		})
		return
	}

	replyQ, err := ch.QueueDeclare(
		"",    // name: empty → broker generates one
		false, // durable
		true,  // auto-delete when unused
		true,  // exclusive
		false, // no-wait
		nil,
	)
	log.Printf("Queue declared")
	if err != nil {
		c.JSON(http.StatusInternalServerError, AvailableResp{
			Status:      "error",
			ErrorDetail: "queue declare failed: " + err.Error(),
		})
		log.Printf("JSON ERROR")
		return
	}

	msgs, err := ch.Consume(
		replyQ.Name,
		"",    // consumer tag
		true,  // auto-ack
		true,  // exclusive
		false, // no-local
		false, // no-wait
		nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, AvailableResp{
			Status:      "error",
			ErrorDetail: "consume start failed: " + err.Error(),
		})
		return
	}

	corrID := uuid.New().String()
	reqBody, _ := json.Marshal(req)

	if err := ch.Publish(
		"clearSky.events", // exchange
		"credits.avail",   // routing key
		false, false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			Body:          reqBody,
		},
	); err != nil {
		c.JSON(http.StatusInternalServerError, AvailableResp{
			Status:      "error",
			ErrorDetail: "publish failed: " + err.Error(),
		})
		return
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			c.JSON(http.StatusGatewayTimeout, AvailableResp{
				Status:      "error",
				ErrorDetail: "timeout waiting for service",
			})
			return

		case d := <-msgs:
			// ignore other correlation IDs
			if d.CorrelationId != corrID {
				continue
			}

			var resp AvailableResp
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				c.JSON(http.StatusInternalServerError, AvailableResp{
					Status:      "error",
					ErrorDetail: "unmarshal reply failed: " + err.Error(),
				})
				return
			}

			statusCode := http.StatusOK
			if resp.Status != "ok" {
				statusCode = http.StatusBadRequest
			}
			c.JSON(statusCode, resp)
			return
		}
	}
}

// this function will be used after uploaded final grades.
func HandleCreditsSpent(ch *amqp.Channel) error {
	type Payload struct {
		Name   string  `json:"name"`
		Amount float64 `json:"amount"`
	}
	body := Payload{
		Name:   "NTUA",
		Amount: 1,
	}
	jsonbody, err := json.Marshal(body)
	if err != nil {
		return err
	}
	return ch.Publish(
		"clearSky.events",
		"credits.spent",
		false,
		false,
		amqp.Publishing{
			ContentType:  "application/json",
			DeliveryMode: amqp.Persistent,
			Body:         jsonbody,
		},
	)
}

func HandleFinalGradesInc(req PurchaseRequest, ch *amqp.Channel) error {
	jsonbody, err := json.Marshal(req)

	if err != nil {
		return err
	}
	return ch.Publish(
		"clearSky.events",
		"incr.credits",
		false,
		false,
		amqp.Publishing{
			ContentType:  "application/json",
			DeliveryMode: amqp.Persistent,
			Body:         jsonbody,
		},
	)
}

func HandleCreditsPurchased(c *gin.Context, ch *amqp.Channel) {
	log.Println("[HandleCreditsPurchased] → entered")

	// 1. Bind JSON
	var req PurchaseRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("[HandleCreditsPurchased] ❌ bind error: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	log.Printf("[HandleCreditsPurchased] 📥 request: name=%s amount=%d", req.Name, req.Amount)

	// 2. Declare a temporary reply queue
	log.Println("[HandleCreditsPurchased] ⏳ declaring reply queue")
	replyQ, err := ch.QueueDeclare(
		"",    // empty name = broker-generated
		false, // durable
		true,  // auto-delete
		true,  // exclusive
		false, // no-wait
		nil,   // args
	)
	if err != nil {
		log.Printf("[HandleCreditsPurchased] ❌ QueueDeclare failed: %v", err)
		c.JSON(http.StatusInternalServerError, PurchaseResponse{
			Status:  "error",
			Message: "failed to create reply queue",
			Error:   err.Error(),
		})
		return
	}
	log.Printf("[HandleCreditsPurchased] ✅ declared reply queue: %s", replyQ.Name)

	// 3. Start consuming replies
	log.Printf("[HandleCreditsPurchased] ⏳ start consuming on %s", replyQ.Name)
	msgs, err := ch.Consume(
		replyQ.Name,
		"",    // consumer tag
		true,  // auto-ack
		true,  // exclusive
		false, // no-local
		false, // no-wait
		nil,
	)
	if err != nil {
		log.Printf("[HandleCreditsPurchased] ❌ Consume failed: %v", err)
		c.JSON(http.StatusInternalServerError, PurchaseResponse{
			Status:  "error",
			Message: "failed to start consuming replies",
			Error:   err.Error(),
		})
		return
	}
	log.Println("[HandleCreditsPurchased] ✅ consumer started")

	// 4. Publish the event
	corrID := uuid.New().String()
	body, _ := json.Marshal(req)
	log.Printf("[HandleCreditsPurchased] ⏳ publishing to exchange=clearSky.events routingKey=credits.purchased corrID=%s", corrID)
	err = ch.Publish(
		"clearSky.events",   // exchange
		"credits.purchased", // routing key
		false,               // mandatory
		false,               // immediate
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			Body:          body,
		},
	)
	if err != nil {
		log.Printf("[HandleCreditsPurchased] ❌ Publish failed: %v", err)
		c.JSON(http.StatusInternalServerError, PurchaseResponse{
			Status:  "error",
			Message: "failed to publish request",
			Error:   err.Error(),
		})
		return
	}
	log.Println("[HandleCreditsPurchased] ✅ published, waiting for reply...")

	// 5. Wait for reply (with timeout)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			log.Println("[HandleCreditsPurchased] ⏰ timeout waiting for reply")
			c.JSON(http.StatusGatewayTimeout, PurchaseResponse{
				Status:  "error",
				Message: "service timeout",
			})
			return

		case d := <-msgs:
			log.Printf("[HandleCreditsPurchased] 🔔 got delivery corrID=%s", d.CorrelationId)
			if d.CorrelationId != corrID {
				log.Printf("[HandleCreditsPurchased] 🔍 ignoring stray message (corrID=%s)", d.CorrelationId)
				continue
			}

			log.Println("[HandleCreditsPurchased] ⏳ unmarshalling reply")
			var resp PurchaseResponse
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				log.Printf("[HandleCreditsPurchased] ❌ invalid reply format: %v", err)
				c.JSON(http.StatusInternalServerError, PurchaseResponse{
					Status:  "error",
					Message: "invalid reply format",
					Error:   err.Error(),
				})
				return
			}

			statusCode := http.StatusOK
			if resp.Status != "ok" {
				statusCode = http.StatusBadRequest
			}
			log.Printf("[HandleCreditsPurchased] ✅ replying to client with status=%d message=%q", statusCode, resp.Message)
			HandleFinalGradesInc(req, ch)
			c.JSON(statusCode, resp)
			return
		}
	}
}

===== orchestrator/internal/handlers/grades.go =====
package handlers

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"io"
	"log"
	"net/http"
	"path/filepath"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	amqp "github.com/rabbitmq/amqp091-go"
	"github.com/xuri/excelize/v2"
)

// Reply coming back from the grades worker
type ExcelUploadResponse struct {
	Status  string `json:"status"`  // "ok" | "error"
	Message string `json:"message"` // free-text
	Error   string `json:"error,omitempty"`
}

// UploadExcelInit – Gin controller
//
// Expects a multipart field named "file" with a .xlsx inside.
// Publishes the workbook to RabbitMQ (base-64 string) and waits up to 10 s
// for a JSON reply from the worker.
func UploadExcelInit(c *gin.Context, ch *amqp.Channel) {
	//------------------------------------------------------------
	// 1) Receive + quick template validation
	//------------------------------------------------------------
	file, err := c.FormFile("file")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no file received"})
		return
	}
	if filepath.Ext(file.Filename) != ".xlsx" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "only .xlsx files allowed"})
		return
	}

	src, _ := file.Open()
	defer src.Close()

	var buf bytes.Buffer
	if _, err = io.Copy(&buf, src); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to read file"})
		return
	}

	// Very light-weight check so we don’t send garbage downstream
	if _, err := excelize.OpenReader(bytes.NewReader(buf.Bytes())); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid Excel file"})
		return
	}

	//------------------------------------------------------------
	// 2) Build RPC envelope
	//------------------------------------------------------------
	replyQ, err := ch.QueueDeclare(
		"",    // broker generates a random name
		false, // durable
		true,  // auto-delete
		true,  // exclusive
		false, // no-wait
		nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "cannot declare reply queue"})
		return
	}

	msgs, err := ch.Consume(
		replyQ.Name, "", true, true, false, false, nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "cannot consume reply"})
		return
	}

	corrID := uuid.New().String()

	// ----- publish base-64 string as text/plain -----
	encoded := base64.StdEncoding.EncodeToString(buf.Bytes())

	if err := ch.Publish(
		"clearSky.events", // <<< same exchange your worker binds to
		"postgrades.init",
		false, false,
		amqp.Publishing{
			ContentType:   "text/plain", // makes the message readable in any CLI
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			MessageId:     file.Filename,
			Body:          []byte(encoded),
		},
	); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to publish file"})
		return
	}

	//------------------------------------------------------------
	// 3) Wait for the worker’s reply (10 s timeout)
	//------------------------------------------------------------
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			c.JSON(http.StatusGatewayTimeout, gin.H{"error": "service timeout"})
			return

		case d := <-msgs:
			if d.CorrelationId != corrID {
				continue // stray message
			}

			var resp ExcelUploadResponse
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid reply format"})
				return
			}

			status := http.StatusOK
			if resp.Status != "ok" {
				status = http.StatusBadRequest
			}
			ForwardToStatistics(ch, buf.Bytes(), file.Filename) //update statistics ms
			ForwardToView(ch, buf.Bytes(), file.Filename)
			c.JSON(status, resp)
			return
		}
	}
}

func UploadExcelFinal(c *gin.Context, ch *amqp.Channel) {
	log.Println("[UploadExcelFinal] Receiving file...")

	// 1) Receive + quick template validation
	file, err := c.FormFile("file")
	if err != nil {
		log.Println("[UploadExcelFinal] No file received")
		c.JSON(http.StatusBadRequest, gin.H{"error": "no file received"})
		return
	}

	if filepath.Ext(file.Filename) != ".xlsx" {
		log.Printf("[UploadExcelFinal] Invalid file extension: %s\n", file.Filename)
		c.JSON(http.StatusBadRequest, gin.H{"error": "only .xlsx files allowed"})
		return
	}

	log.Printf("[UploadExcelFinal] Validating file: %s\n", file.Filename)
	src, _ := file.Open()
	defer src.Close()

	var buf bytes.Buffer
	if _, err = io.Copy(&buf, src); err != nil {
		log.Printf("[UploadExcelFinal] Failed to read file: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to read file"})
		return
	}

	if _, err := excelize.OpenReader(bytes.NewReader(buf.Bytes())); err != nil {
		log.Printf("[UploadExcelFinal] Excel validation failed: %v\n", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid Excel file"})
		return
	}

	// 2) Build RPC envelope
	log.Println("[UploadExcelFinal] Declaring reply queue...")
	replyQ, err := ch.QueueDeclare(
		"", false, true, true, false, nil,
	)
	if err != nil {
		log.Printf("[UploadExcelFinal] Failed to declare reply queue: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "cannot declare reply queue"})
		return
	}

	log.Printf("[UploadExcelFinal] Consuming from reply queue: %s\n", replyQ.Name)
	msgs, err := ch.Consume(
		replyQ.Name, "", true, true, false, false, nil,
	)
	if err != nil {
		log.Printf("[UploadExcelFinal] Failed to consume from reply queue: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "cannot consume reply"})
		return
	}

	corrID := uuid.New().String()
	log.Printf("[UploadExcelFinal] Correlation ID: %s\n", corrID)

	encoded := base64.StdEncoding.EncodeToString(buf.Bytes())
	log.Println("[UploadExcelFinal] Publishing file to postgrades.final...")

	if err := ch.Publish(
		"clearSky.events",
		"postgrades.final",
		false, false,
		amqp.Publishing{
			ContentType:   "text/plain",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			MessageId:     file.Filename,
			Body:          []byte(encoded),
		},
	); err != nil {
		log.Printf("[UploadExcelFinal] Failed to publish message: %v\n", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to publish file"})
		return
	}

	log.Println("[UploadExcelFinal] Waiting for reply from worker...")
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			log.Println("[UploadExcelFinal] Timeout waiting for reply")
			c.JSON(http.StatusGatewayTimeout, gin.H{"error": "service timeout"})
			return

		case d := <-msgs:
			if d.CorrelationId != corrID {
				log.Println("[UploadExcelFinal] Ignoring unrelated message")
				continue
			}

			log.Println("[UploadExcelFinal] Received reply from worker")
			var resp ExcelUploadResponse
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				log.Printf("[UploadExcelFinal] Failed to unmarshal reply: %v\n", err)
				c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid reply format"})
				return
			}

			log.Println("[UploadExcelFinal] Calling HandleCreditsSpent...")
			if err := HandleCreditsSpent(ch); err != nil { //update credits ms
				log.Printf("[UploadExcelFinal] Failed to publish credits spent: %v\n", err)
				c.JSON(http.StatusInternalServerError, gin.H{
					"status":  "error",
					"message": "failed to publish credits spent",
					"error":   err.Error(),
				})
				return
			}

			log.Println("[UploadExcelFinal] Upload successful, credits deducted")
			ForwardToStatistics(ch, buf.Bytes(), file.Filename) //update statistics ms
			ForwardToView(ch, buf.Bytes(), file.Filename)
			c.JSON(http.StatusOK, gin.H{
				"status":  resp.Status,
				"message": "final grades uploaded and credits deducted",
				"details": resp,
			})
			return
		}
	}
}

===== orchestrator/internal/handlers/institution.go =====
package handlers

import (
	"context"
	"encoding/json"
	"log"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	amqp "github.com/rabbitmq/amqp091-go"
)

type UserRequest struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Director string `json:"director"`
}

// Response is sent back to the orchestrator
type Response struct {
	Status  string `json:"status"`  // "ok", "conflict", "error"
	Message string `json:"message"` // details for humans
	// code    int    `json:"code"`
	ErrorDetail string `json:"error,omitempty"` // optional error text
}

type AddInstitutionResp struct {
	Status      string `json:"status"`          // "ok" or "error"
	Message     string `json:"message"`         // human-readable
	ErrorDetail string `json:"error,omitempty"` // optional error text
}

type AddInstitutionReq struct {
	Name string `json:"name" binding:"required"`
}

// PublishAddInstitution publishes an "add.new" event for a given institution.
func PublishAddInstitution(ch *amqp.Channel, req AddInstitutionReq) error {
	corrID := uuid.New().String()
	body, err := json.Marshal(req)
	if err != nil {
		return err
	}
	return ch.Publish(
		"clearSky.events", // exchange
		"add.new",         // routing key
		false, false,      // mandatory, immediate
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			Body:          body,
		},
	)
}

func HandleInstitutionRegistered(c *gin.Context, ch *amqp.Channel) {
	log.Println("Calling registration service...")

	var req UserRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{
			Status:      "error",
			ErrorDetail: err.Error(),
		})
		return
	}

	// Declare a temporary reply queue.
	replyQ, err := ch.QueueDeclare(
		"",    // empty → broker-named queue
		false, // durable
		true,  // auto-delete
		true,  // exclusive
		false, // no-wait
		nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, Response{
			Status:      "error",
			ErrorDetail: "queue declare failed: " + err.Error(),
		})
		return
	}

	// Start consuming from the reply queue.
	msgs, err := ch.Consume(
		replyQ.Name,
		"",    // consumer tag
		true,  // auto-ack
		true,  // exclusive
		false, // no-local
		false, // no-wait
		nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, Response{
			Status:      "error",
			ErrorDetail: "consume start failed: " + err.Error(),
		})
		return
	}

	// Publish the "institution.registered" event.
	corrID := uuid.New().String()
	reqBody, err := json.Marshal(req)
	if err != nil {
		c.JSON(http.StatusInternalServerError, Response{
			Status:      "error",
			ErrorDetail: "marshal request failed: " + err.Error(),
		})
		return
	}

	if err := ch.Publish(
		"clearSky.events",        // exchange
		"institution.registered", // routing key
		false, false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			Body:          reqBody,
		},
	); err != nil {
		c.JSON(http.StatusInternalServerError, Response{
			Status:      "error",
			ErrorDetail: "publish failed: " + err.Error(),
		})
		return
	}

	// Wait for a reply or timeout.
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			c.JSON(http.StatusGatewayTimeout, Response{
				Status:      "error",
				ErrorDetail: "timeout waiting for service",
			})
			return

		case d := <-msgs:
			if d.CorrelationId != corrID {
				continue
			}
			var resp Response
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				c.JSON(http.StatusInternalServerError, Response{
					Status:      "error",
					ErrorDetail: "unmarshal reply failed: " + err.Error(),
				})
				return
			}

			statusCode := http.StatusOK
			if resp.Status != "ok" {
				statusCode = http.StatusBadRequest
			}
			c.JSON(statusCode, resp)

			// After successful registration, publish add.new event.
			addReq := AddInstitutionReq{Name: req.Name}
			if err := PublishAddInstitution(ch, addReq); err != nil {
				log.Printf("failed to publish add institution: %v", err)
			}
			return
		}
	}
}

===== orchestrator/internal/handlers/personal.go =====
package handlers

// RabbitMQ handlers for retrieving personal grades information. The orchestrator
// exposes HTTP endpoints that forward the requests to the personal grades
// service using RPC-style messaging.

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"log"
	"net/http"
	"orchestrator/internal/middleware"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	amqp "github.com/rabbitmq/amqp091-go"
)

// When upload grades, update view grades too.

func ForwardToView(ch *amqp.Channel, fileData []byte, filename string) {
	log.Println("[ForwardToView] Encoding data for VIEWING THEM")

	// Base64 encode the file contents
	encoded := base64.StdEncoding.EncodeToString(fileData)
	// Log the encoded payload (optional)
	log.Printf("[ForwardToView] Payload (base64): %s", encoded)

	// Prepare the persistent message
	msg := amqp.Publishing{
		ContentType:  "text/plain",
		DeliveryMode: amqp.Persistent, // ✅ Makes message durable
		MessageId:    filename,        // Optional metadata
		Timestamp:    time.Now(),      // Optional timestamp
		Body:         []byte(encoded),
	}

	log.Println("[ForwardToView] Publishing to postgrades.VIEW")

	// Publish to exchange with the durable routing key
	err := ch.Publish(
		"clearSky.events", // 🔁 Exchange name (must exist and be durable)
		"postgrades.view", // 🎯 Routing key (must match queue binding)
		false,              // mandatory
		false,              // immediate
		msg,
	)

	if err != nil {
		log.Printf("[ForwardToView] Failed to publish VIEW message: %v\n", err)
	} else {
		log.Println("[ForwardToView] VIEW message published successfully")
	}
}

func HandleGetPersonalGrades(c *gin.Context, ch *amqp.Channel) {
	log.Println("[HandleGetPersonalGrades] → entered")

	// Get student_id from JWT context using middleware helper
	studentID := middleware.GetStudentID(c)
	if studentID == "" {
		log.Printf("[HandleGetPersonalGrades] ❌ student ID not found in context")
		c.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required. Please ensure you're logged in as a student."})
		return
	}

	log.Printf("[HandleGetPersonalGrades] 📥 Received request for student_id: %s", studentID)

	// Build request with student_id from JWT
	req := struct {
		StudentID string `json:"AM"`
	}{
		StudentID: studentID,
	}
	log.Println("[HandleGetPersonalGrades] 🔧 Built request payload")

	// Marshal and log the JSON payload
	body, err := json.Marshal(req)
	if err != nil {
		log.Printf("[HandleGetPersonalGrades] ❌ Failed to marshal request: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to prepare request payload"})
		return
	}
	log.Printf("[HandleGetPersonalGrades] Payload: %s", string(body))

	// Declare reply queue
	replyQ, err := ch.QueueDeclare(
		"", false, true, true, false, nil,
	)
	if err != nil {
		log.Printf("[HandleGetPersonalGrades] ❌ Failed to declare reply queue: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create reply queue"})
		return
	}
	log.Printf("[HandleGetPersonalGrades] ✅ Reply queue declared: %s", replyQ.Name)

	// Start consuming
	msgs, err := ch.Consume(
		replyQ.Name, "", true, true, false, false, nil,
	)
	if err != nil {
		log.Printf("[HandleGetPersonalGrades] ❌ Failed to start consuming: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to consume reply"})
		return
	}
	log.Println("[HandleGetPersonalGrades] 🟢 Started consuming from reply queue")

	// Publish request with correlation ID and reply-to
	corrID := uuid.New().String()
	log.Printf("[HandleGetPersonalGrades] 📦 Publishing message with Correlation ID: %s", corrID)
	err = ch.Publish(
		"clearSky.events",
		"view.avail",
		false, false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			Body:          body,
		},
	)
	if err != nil {
		log.Printf("[HandleGetPersonalGrades] ❌ Publish failed: %v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to publish request"})
		return
	}
	log.Println("[HandleGetPersonalGrades] 🚀 Request published successfully")

	// Set timeout for reply
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	log.Println("[HandleGetPersonalGrades] ⏳ Waiting for response...")
	for {
		select {
		case <-ctx.Done():
			log.Println("[HandleGetPersonalGrades] ⏰ Timeout while waiting for reply")
			c.JSON(http.StatusGatewayTimeout, gin.H{"error": "Service timeout"})
			return

		case d := <-msgs:
			log.Printf("[HandleGetPersonalGrades] 📬 Received message with Correlation ID: %s", d.CorrelationId)

			// Ignore messages with wrong correlation ID
			if d.CorrelationId != corrID {
				log.Printf("[HandleGetPersonalGrades] 🔄 Ignoring mismatched Correlation ID: %s", d.CorrelationId)
				continue
			}

			// Log raw JSON response payload
			log.Printf("[HandleGetPersonalGrades] Response payload: %s", string(d.Body))

			var gradesResp struct {
				Status string        `json:"status"`
				Data   []interface{} `json:"data"`
			}

			if err := json.Unmarshal(d.Body, &gradesResp); err != nil {
				log.Printf("[HandleGetPersonalGrades] ❌ Failed to unmarshal response: %v", err)
				c.JSON(http.StatusInternalServerError, gin.H{"error": "Invalid response format"})
				return
			}

			log.Printf("[HandleGetPersonalGrades] ✅ Successfully received response with status: %s", gradesResp.Status)

			statusCode := http.StatusOK
			if gradesResp.Status != "ok" {
				log.Printf("[HandleGetPersonalGrades] ⚠️ Non-ok status received: %s", gradesResp.Status)
				statusCode = http.StatusBadRequest
			}

			log.Printf("[HandleGetPersonalGrades] 📤 Sending JSON response with status code: %d", statusCode)
			c.JSON(statusCode, gradesResp)
			return
		}
	}
}

===== orchestrator/internal/handlers/review.go =====
package handlers

import (
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"orchestrator/internal/middleware"
	"time"

	"github.com/gin-gonic/gin"
	amqp "github.com/rabbitmq/amqp091-go"
)

// Assume all data received from json.

// helperRequest sends the payload to the given routing key on ExchangeKey and waits for a JSON response
func helperRequest(ch *amqp.Channel, routingKey string, payload []byte) (map[string]interface{}, error) {
	fmt.Printf("Outgoing payload: %s\n routing key: %s\n", payload, routingKey)

	corrID := "abc123"
	replyQueue, err := ch.QueueDeclare("", false, true, true, false, nil)
	if err != nil {
		return nil, err
	}

	msgs, err := ch.Consume(replyQueue.Name, "", true, false, false, false, nil)
	if err != nil {
		return nil, err
	}

	err = ch.Publish(
		"clearSky.events", // publish to the direct exchange
		routingKey,
		false,
		false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQueue.Name,
			Body:          payload,
		},
	)
	if err != nil {
		return nil, err
	}

	timeout := time.After(5 * time.Second)
	for {
		select {
		case msg := <-msgs:
			if msg.CorrelationId == corrID {
				var response map[string]interface{}
				err := json.Unmarshal(msg.Body, &response)
				return response, err
			}
		case <-timeout:
			return nil, errors.New("timeout waiting for response")
		}
	}
}

// handleReviewRequested processes new request events
// -> sends 2 events: student.postNewRequest & instructor.insertStudentRequest
func HandlePostNewRequest(c *gin.Context, ch *amqp.Channel) {
	// Get student info from JWT using middleware helpers

	// IN STUDENT AND INSTRUCTOR SERVICE, USERID IS STUDENT ID, INSTRUCTORS ARE DEFINED BY COUSCES
	studentID := middleware.GetStudentID(c)
	userID := middleware.GetStudentID(c)

	if !middleware.IsStudent(c) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only students can submit review requests"})
		return
	}

	if studentID == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required for review requests"})
		return
	}

	var req struct {
		CourseID       string `json:"course_id"`
		StudentMessage string `json:"student_message"`
		ExamPeriod     string `json:"exam_period"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// Build payload with student info from JWT
	payload, _ := json.Marshal(map[string]interface{}{
		"body": map[string]interface{}{
			"exam_period":     req.ExamPeriod,
			"course_id":       req.CourseID,
			"user_id":         userID,
			"student_id":      studentID, // Add student_id from JWT
			"student_message": req.StudentMessage,
		},
	})

	responseStudent, err := helperRequest(ch, "student.postNewRequest", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseStudent})
	responseInstructor, err := helperRequest(ch, "instructor.insertStudentRequest", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseInstructor})
}

// handleGetRequestStatus processes student sees request status events
// -> sends 1 event: student.getRequestStatus
func HandleGetRequestStatus(c *gin.Context, ch *amqp.Channel) {
	// Get student info from JWT using middleware helpers

	// IN STUDENT AND INSTRUCTOR SERVICE, USERID IS STUDENT ID, INSTRUCTORS ARE DEFINED BY COUSCES
	studentID := middleware.GetStudentID(c)
	userID := middleware.GetStudentID(c)

	if !middleware.IsStudent(c) {
		c.JSON(http.StatusForbidden, gin.H{"error": "Only students can check request status"})
		return
	}

	var req struct {
		CourseID   string `json:"course_id"`
		ExamPeriod string `json:"exam_period"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	payload, _ := json.Marshal(map[string]interface{}{
		"body": map[string]interface{}{
			"exam_period": req.ExamPeriod,
			"course_id":   req.CourseID,
			"user_id":     userID,
			"student_id":  studentID, // Add student_id from JWT
		},
	})
	responseStudent, err := helperRequest(ch, "student.getRequestStatus", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseStudent})
}

// handlePostResponse processes responses on review requests
// -> sends 2 events: student.updateInstructorResponse & instructor.postResponse
func HandlePostResponse(c *gin.Context, ch *amqp.Channel) {
	// receive message
	var req struct {
		CourseID               string `json:"course_id"`
		UserID                 string `json:"user_id"`
		ExamPeriod             string `json:"exam_period"`
		InstructorReplyMessage string `json:"instructor_reply_message"`
		InstructorAction       string `json:"instructor_action"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// add message payload
	payload, _ := json.Marshal(map[string]interface{}{
		"body": map[string]interface{}{
			"exam_period":              req.ExamPeriod,
			"course_id":                req.CourseID,
			"user_id":                  req.UserID,
			"instructor_reply_message": req.InstructorReplyMessage,
			"instructor_action":        req.InstructorAction,
		},
	})

	responseStudent, err := helperRequest(ch, "student.updateInstructorResponse", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseStudent})
	responseInstructor, err := helperRequest(ch, "instructor.postResponse", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseInstructor})
}

// handleGetRequestList processes instructor get list of pending requests
// -> sends 1 event: instructor.getRequestsList
func HandleGetRequestList(c *gin.Context, ch *amqp.Channel) {
	// receive message
	var req struct {
		CourseID   string `json:"course_id"`
		ExamPeriod string `json:"exam_period"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// add message payload
	payload, _ := json.Marshal(map[string]interface{}{
		"body": map[string]interface{}{
			"exam_period": req.ExamPeriod,
			"course_id":   req.CourseID,
		},
	})
	responseInstructor, err := helperRequest(ch, "instructor.getRequestsList", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseInstructor})
}

// handleGetRequestInfo processes instructor sees request details
// -> sends 1 event: instructor.getRequestInfo
func HandleGetRequestInfo(c *gin.Context, ch *amqp.Channel) {
	// receive message
	var req struct {
		CourseID   string `json:"course_id"`
		UserID     string `json:"user_id"`
		ExamPeriod string `json:"exam_period"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	// add message payload
	payload, _ := json.Marshal(map[string]interface{}{
		"body": map[string]interface{}{
			"exam_period": req.ExamPeriod,
			"course_id":   req.CourseID,
			"user_id":     req.UserID,
		},
	})
	responseInstructor, err := helperRequest(ch, "instructor.getRequestInfo", payload)
	if err != nil {
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"data": responseInstructor})
}

===== orchestrator/internal/handlers/statistics.go =====
package handlers

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"log"
	"net/http"
	"orchestrator/internal/middleware"
	"time"

	"github.com/gin-gonic/gin"
	amqp "github.com/rabbitmq/amqp091-go"
)

// submissionLogResponse matches the shape your JS microservice replies with:
type submissionLogResponse struct {
	Status  string          `json:"status"`            // "ok" or "error"
	Message string          `json:"message,omitempty"` // error message
	Data    json.RawMessage `json:"data,omitempty"`    // actual rows
}

// randomCorrelationID generates a random hex string for correlation.
func randomCorrelationID(n int) (string, error) {
	b := make([]byte, n)
	if _, err := rand.Read(b); err != nil {
		return "", err
	}
	return hex.EncodeToString(b), nil
}

// HandleSubmissionLogs asks the JS microservice for all submission logs
func HandleSubmissionLogs(c *gin.Context, ch *amqp.Channel) {
	// Get user context from JWT using middleware helpers
	role := middleware.GetRole(c)
	studentID := middleware.GetStudentID(c)
	userID := middleware.GetUserID(c)

	// Build request with user context
	requestPayload := map[string]interface{}{
		"role":    role,
		"user_id": userID,
	}

	// Add student_id for student users
	if role == "student" && studentID != "" {
		requestPayload["student_id"] = studentID
	}

	// 1) Declare a temporary reply queue
	replyQ, err := ch.QueueDeclare(
		"",    // let RabbitMQ generate a random name
		false, // durable
		true,  // delete when unused
		true,  // exclusive
		false, // no-wait
		nil,   // arguments
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "queue declare failed: " + err.Error()})
		return
	}

	msgs, err := ch.Consume(
		replyQ.Name,
		"",    // consumer
		true,  // auto-ack
		false, // exclusive
		false, // no-local
		false, // no-wait
		nil,
	)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "consume on reply queue failed: " + err.Error()})
		return
	}

	// 2) Generate a correlation ID
	corrID, err := randomCorrelationID(16)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "could not generate correlation ID"})
		return
	}

	// 3) Publish the request to the same exchange/routing key your JS service listens on
	body, _ := json.Marshal(requestPayload)
	if err := ch.Publish(
		"clearSky.events", // RABBITMQ_EXCHANGE
		"stats.avail",     // RABBITMQ_SEND_AVAIL_KEY
		false, false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			Body:          body,
		},
	); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "publish failed: " + err.Error()})
		return
	}

	// 4) Wait for the matching response (with timeout!)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			c.JSON(http.StatusGatewayTimeout, gin.H{"error": "timeout waiting for submission logs"})
			return

		case d := <-msgs:
			if d.CorrelationId != corrID {
				continue // not ours, skip
			}

			var resp submissionLogResponse
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid response format"})
				return
			}

			if resp.Status != "ok" {
				c.JSON(http.StatusBadGateway, gin.H{"error": resp.Message})
				return
			}

			// Success! return the raw data.
			c.Data(http.StatusOK, "application/json", resp.Data)
			return
		}
	}
}

// DistributionRequest represents the payload for fetching grade distributions.
type DistributionRequest struct {
	ClassID  string `json:"class_id"`
	ExamDate string `json:"exam_date"`
}

func ForwardToStatistics(ch *amqp.Channel, fileData []byte, filename string) {
	log.Println("[ForwardToStatistics] Encoding data for statistics")

	// Base64 encode the file contents
	encoded := base64.StdEncoding.EncodeToString(fileData)

	// Prepare the persistent message
	msg := amqp.Publishing{
		ContentType:  "text/plain",
		DeliveryMode: amqp.Persistent, // ✅ Makes message durable
		MessageId:    filename,        // Optional metadata
		Timestamp:    time.Now(),      // Optional timestamp
		Body:         []byte(encoded),
	}

	log.Println("[ForwardToStatistics] Publishing to postgrades.statistics")

	// Publish to exchange with the durable routing key
	err := ch.Publish(
		"clearSky.events",       // 🔁 Exchange name (must exist and be durable)
		"postgrades.statistics", // 🎯 Routing key (must match queue binding)
		false,                   // mandatory
		false,                   // immediate
		msg,
	)

	if err != nil {
		log.Printf("[ForwardToStatistics] Failed to publish statistics message: %v\n", err)
	} else {
		log.Println("[ForwardToStatistics] Statistics message published successfully")
	}
}

type rpcResponse struct {
	Status  string              `json:"status"`
	Message string              `json:"message,omitempty"`
	Data    map[string]struct { // e.g. "grade", "Q1"…
		Categories []int `json:"categories"`
		Data       []int `json:"data"`
	} `json:"data,omitempty"`
}

type getGradesRequest struct {
	Course            string `json:"course"            binding:"required"`
	DeclarationPeriod string `json:"declarationPeriod" binding:"required"`
	ClassTitle        string `json:"classTitle"        binding:"required"`
}

// HandleGetGrades is your Gin handler
func HandleGetGrades(ch *amqp.Channel) gin.HandlerFunc {

	return func(c *gin.Context) {
		// 1) bind JSON
		var req getGradesRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// 2) declare a temporary reply queue
		replyQ, err := ch.QueueDeclare(
			"",    // let RabbitMQ name it
			false, // durable
			true,  // delete when unused
			true,  // exclusive
			false, // no-wait
			nil,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "queue declare: " + err.Error()})
			return
		}

		msgs, err := ch.Consume(
			replyQ.Name,
			"",    // consumer
			true,  // auto-ack
			false, // exclusive
			false, // no-local
			false, // no-wait
			nil,
		)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "consume reply queue: " + err.Error()})
			return
		}

		// 3) publish the RPC request
		corrID, err := randomCorrelationID(16)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "generate corrID: " + err.Error()})
			return
		}

		body, _ := json.Marshal(req)
		if err := ch.Publish(
			"clearSky.events", // exchange
			"stats.get",       // routing key
			false, false,
			amqp.Publishing{
				ContentType:   "application/json",
				CorrelationId: corrID,
				ReplyTo:       replyQ.Name,
				Body:          body,
			},
		); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "publish RPC: " + err.Error()})
			return
		}

		// 4) wait for the reply
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		for {
			select {
			case <-ctx.Done():
				c.JSON(http.StatusGatewayTimeout, gin.H{"error": "timeout waiting for grades"})
				return

			case d := <-msgs:
				if d.CorrelationId != corrID {
					continue
				}

				var resp rpcResponse
				if err := json.Unmarshal(d.Body, &resp); err != nil {
					c.JSON(http.StatusInternalServerError, gin.H{"error": "bad RPC response"})
					return
				}

				if resp.Status != "ok" {
					c.JSON(http.StatusBadGateway, gin.H{"error": resp.Message})
					return
				}

				c.JSON(http.StatusOK, resp.Data)
				return
			}
		}
	}
}

// Add helper functions
func GetRole(c *gin.Context) string {
	if role, exists := c.Get("role"); exists && role != nil {
		if str, ok := role.(string); ok {
			return str
		}
	}
	return ""
}

func GetStudentID(c *gin.Context) string {
	if studentID, exists := c.Get("student_id"); exists && studentID != nil {
		if str, ok := studentID.(string); ok {
			return str
		}
	}
	return ""
}

func GetUserID(c *gin.Context) string {
	if userID, exists := c.Get("user_id"); exists && userID != nil {
		if str, ok := userID.(string); ok {
			return str
		}
	}
	return ""
}

===== orchestrator/internal/handlers/user.go =====
package handlers

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"log"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	amqp "github.com/rabbitmq/amqp091-go"
)

// Helper for RPC via RabbitMQ
func rpcRequest(ch *amqp.Channel, exchange, routingKey string, reqBody interface{}) (map[string]interface{}, error) {
	body, _ := json.Marshal(reqBody)
	corrID := uuid.New().String()

	log.Printf("[RPC] Preparing request → Exchange: %q, RoutingKey: %q, CorrID: %s, Payload: %s", exchange, routingKey, corrID, string(body))

	replyQ, err := ch.QueueDeclare("", false, true, true, false, nil)
	if err != nil {
		log.Printf("[RPC] Failed to declare reply queue: %v", err)
		return nil, err
	}

	msgs, err := ch.Consume(replyQ.Name, "", true, true, false, false, nil)
	if err != nil {
		log.Printf("[RPC] Failed to consume from reply queue: %v", err)
		return nil, err
	}

	err = ch.Publish(
		exchange,
		routingKey,
		false, false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQ.Name,
			Body:          body,
		},
	)
	if err != nil {
		log.Printf("[RPC] Failed to publish message: %v", err)
		return nil, err
	}

	log.Printf("[RPC] Published message. Awaiting response...")

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	for {
		select {
		case <-ctx.Done():
			log.Printf("[RPC] Timeout waiting for response for CorrID: %s", corrID)
			return nil, context.DeadlineExceeded
		case d := <-msgs:
			if d.CorrelationId != corrID {
				log.Printf("[RPC] Skipping unrelated CorrID: %s", d.CorrelationId)
				continue
			}
			var resp map[string]interface{}
			if err := json.Unmarshal(d.Body, &resp); err != nil {
				log.Printf("[RPC] Failed to unmarshal response: %v", err)
				return nil, err
			}
			log.Printf("[RPC] Received response for CorrID %s: %s", corrID, string(d.Body))
			return resp, nil
		}
	}
}

// User Registration
func HandleUserRegister(c *gin.Context, ch *amqp.Channel) {
	var req struct {
		Username  string `json:"username" binding:"required"`
		Password  string `json:"password" binding:"required"`
		Role      string `json:"role,omitempty"`
		StudentID string `json:"student_id,omitempty"` // Add student_id field
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("[Register] Invalid request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "username and password are required"})
		return
	}

	if req.Role == "" {
		req.Role = "student"
	}

	// Validate student_id for student role
	if req.Role == "student" && req.StudentID == "" {
		log.Printf("[Register] Student ID required for student role")
		c.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required for student registration"})
		return
	}

	log.Printf("[Register] Registering user: %s with role: %s, student_id: %s", req.Username, req.Role, req.StudentID)

	payload := map[string]interface{}{
		"type":       "register",
		"username":   req.Username,
		"password":   req.Password,
		"role":       req.Role,
		"student_id": req.StudentID, // Include student_id in payload
	}
	resp, err := rpcRequest(ch, "", "auth.request", payload)
	if err != nil {
		log.Printf("[Register] RPC error: %v", err)
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	log.Printf("[Register] Registration response: %+v", resp)
	c.JSON(http.StatusOK, resp)
}

// User Login
func HandleUserLogin(c *gin.Context, ch *amqp.Channel) {
	var req struct {
		Username string `json:"username"`
		Password string `json:"password"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("[Login] Invalid request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}

	log.Printf("[Login] Logging in user: %s", req.Username)

	payload := map[string]interface{}{
		"type":     "login",
		"username": req.Username,
		"password": req.Password,
	}
	resp, err := rpcRequest(ch, "", "auth.request", payload)
	if err != nil {
		log.Printf("[Login] RPC error: %v", err)
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	if role, ok := resp["role"]; !ok || role == "" {
		resp["role"] = resp["Role"]
	}
	log.Printf("[Login] Login response: %+v", resp)
	c.JSON(http.StatusOK, resp)
}

// User Delete
func HandleUserDelete(c *gin.Context, ch *amqp.Channel) {
	var req struct {
		Username string `json:"username"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("[Delete] Invalid request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}
	log.Printf("[Delete] Deleting user: %s", req.Username)

	payload := map[string]interface{}{
		"type":     "delete",
		"username": req.Username,
	}
	resp, err := rpcRequest(ch, "", "auth.request", payload)
	if err != nil {
		log.Printf("[Delete] RPC error: %v", err)
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	log.Printf("[Delete] Deletion response: %+v", resp)
	c.JSON(http.StatusOK, resp)
}

// Google Login
func HandleUserGoogleLogin(c *gin.Context, ch *amqp.Channel) {
	var req struct {
		Token string `json:"token"`
		Role  string `json:"role,omitempty"` // Add role support
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("[GoogleLogin] Invalid request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
		return
	}
	log.Printf("[GoogleLogin] Attempting Google login with token for role: %s", req.Role)

	payload := map[string]interface{}{
		"type":  "google_login",
		"token": req.Token,
		"role":  req.Role, // Include role in payload
	}
	resp, err := rpcRequest(ch, "clearSky.events", "auth.login.google", payload)
	if err != nil {
		log.Printf("[GoogleLogin] RPC error: %v", err)
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	log.Printf("[GoogleLogin] Login response: %+v", resp)
	c.JSON(http.StatusOK, resp)
}

// Change Password
func HandleUserChangePassword(c *gin.Context, ch *amqp.Channel) {
	var req struct {
		Username    string `json:"username" binding:"required"`
		OldPassword string `json:"old_password" binding:"required"`
		NewPassword string `json:"new_password" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		log.Printf("[ChangePassword] Invalid request: %v", err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	log.Printf("[ChangePassword] Changing password for user: %s", req.Username)

	payload := map[string]interface{}{
		"type":         "change_password",
		"username":     req.Username,
		"old_password": req.OldPassword,
		"new_password": req.NewPassword,
	}
	log.Printf("[ChangePassword] Publishing RPC payload: %+v", payload)
	resp, err := rpcRequest(ch, "", "auth.request", payload)
	if err != nil {
		log.Printf("[ChangePassword] RPC error: %v", err)
		c.JSON(http.StatusGatewayTimeout, gin.H{"error": err.Error()})
		return
	}
	log.Printf("[ChangePassword] Response: %+v", resp)
	c.JSON(http.StatusOK, resp)
}

// Dummy consumer handler
func HandleUserCreated(d amqp.Delivery) {
	log.Printf("[Handler] user.created event received: %s", string(d.Body))
	if err := d.Ack(false); err != nil {
		log.Printf("[Handler] Failed to ACK message: %v", err)
	}
}

===== orchestrator/internal/middleware/jwt.go =====
package middleware

import (
	"net/http"
	"os"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
)

// JWT secret key from env
var jwtKey = []byte(os.Getenv("JWT_SECRET"))

type Claims struct {
	UserID    string `json:"user_id"`
	Username  string `json:"username,omitempty"`
	Role      string `json:"role"`
	StudentID string `json:"student_id,omitempty"` // Add student_id field
	jwt.RegisteredClaims
}

func JWTAuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header missing"})
			c.Abort()
			return
		}

		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid Authorization header format"})
			c.Abort()
			return
		}

		tokenStr := parts[1]
		claims := &Claims{}
		token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
			return jwtKey, nil
		})
		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		c.Set("user_id", claims.UserID)
		c.Set("username", claims.Username) // Add username to context
		c.Set("role", claims.Role)
		c.Set("student_id", claims.StudentID) // Set student_id in context

		c.Next()
	}
}

// Helper functions for other services to use
func GetUserID(c *gin.Context) string {
	if userID, exists := c.Get("user_id"); exists {
		return userID.(string)
	}
	return ""
}

func GetRole(c *gin.Context) string {
	if role, exists := c.Get("role"); exists {
		return role.(string)
	}
	return ""
}

func GetStudentID(c *gin.Context) string {
	if studentID, exists := c.Get("student_id"); exists && studentID != nil {
		return studentID.(string)
	}
	return ""
}

func IsStudent(c *gin.Context) bool {
	return GetRole(c) == "student"
}

func RequireStudentID() gin.HandlerFunc {
	return func(c *gin.Context) {
		if IsStudent(c) && GetStudentID(c) == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required for this operation"})
			c.Abort()
			return
		}
		c.Next()
	}
}

===== orchestrator/internal/rabbitmq/connection.go =====
package rabbitmq

import (
	"fmt"
	"orchestrator/internal/config"

	amqp "github.com/rabbitmq/amqp091-go"
)

// Connect establishes a connection and channel to RabbitMQ.
func Connect() (*amqp.Connection, *amqp.Channel) {
	conn, err := amqp.Dial(config.Cfg.RabbitMQ.URL)
	if err != nil {
		panic(fmt.Errorf("Dial RabbitMQ failed: %w", err))
	}
	ch, err := conn.Channel()
	if err != nil {
		conn.Close()
		panic(fmt.Errorf("Open channel failed: %w", err))
	}
	return conn, ch
}

// SetupMessaging declares the exchange, queue with DLX, and bindings.
func SetupMessaging(ch *amqp.Channel) error {
	// Declare exchange
	if err := ch.ExchangeDeclare(
		config.Cfg.Exchange.Name,
		config.Cfg.Exchange.Type,
		true, false, false, false, nil,
	); err != nil {
		return fmt.Errorf("ExchangeDeclare failed: %w", err)
	}
	// Declare RPC commands exchange
	if err := ch.ExchangeDeclare(
		"orchestrator.commands", "topic",
		true, false, false, false, nil,
	); err != nil {
		return fmt.Errorf("Commands ExchangeDeclare failed: %w", err)
	}
	// Declare queue with DLX settings
	qArgs := amqp.Table{
		"x-dead-letter-exchange":    config.Cfg.Exchange.Name,
		"x-dead-letter-routing-key": config.Cfg.Queue.DLX,
	}
	if _, err := ch.QueueDeclare(
		config.Cfg.Queue.Name,
		true, false, false, false,
		qArgs,
	); err != nil {
		return fmt.Errorf("QueueDeclare failed: %w", err)
	}
	// Declare DLQ
	if _, err := ch.QueueDeclare(
		config.Cfg.Queue.DLX,
		true, false, false, false, nil,
	); err != nil {
		return fmt.Errorf("DLQ Declare failed: %w", err)
	}
	// Bindings
	for _, key := range config.Cfg.Bindings {
		if err := ch.QueueBind(
			config.Cfg.Queue.Name,
			key,
			config.Cfg.Exchange.Name,
			false, nil,
		); err != nil {
			return fmt.Errorf("QueueBind key '%s' failed: %w", key, err)
		}
	}
	return nil
}

===== orchestrator/internal/rabbitmq/consumer.go =====
package rabbitmq

import (
	"fmt"
	"log"
	"orchestrator/internal/config"
	"orchestrator/internal/handlers"

	amqp "github.com/rabbitmq/amqp091-go"
)

// StartOrchestratorConsumer opens the consumer and dispatches deliveries.
func StartOrchestratorConsumer(ch *amqp.Channel) error {
	msgs, err := ch.Consume(
		config.Cfg.Queue.Name,
		"orchestrator-consumer",
		false, false, false, false, nil,
	)
	if err != nil {
		return fmt.Errorf("Consume failed: %w", err)
	}
	go func() {
		for d := range msgs {
			switch d.RoutingKey {
			case "user.created":
				handlers.HandleUserCreated(d)
			// other cases omitted for brevity
			default:
				log.Printf("[Orchestrator] Unknown key: %s", d.RoutingKey)
				d.Nack(false, false)
			}
		}
	}()
	return nil
}

===== orchestrator/internal/routes/routes.go =====
// orchestrator/internal/routes/routes.go
package routes

import (
	"orchestrator/internal/handlers"
	mw "orchestrator/internal/middleware"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	amqp "github.com/rabbitmq/amqp091-go"
)

// SetupRouter configures all HTTP endpoints and returns the Gin engine.
func SetupRouter(ch *amqp.Channel) *gin.Engine {
	r := gin.Default()

	// Allow CORS in development
	r.Use(cors.New(cors.Config{
		AllowOrigins     : []string{"*"},
		AllowMethods     : []string{"GET", "POST", "PATCH", "DELETE", "OPTIONS"},
		AllowHeaders     : []string{"Origin", "Content-Type", "Accept", "Authorization"},
		ExposeHeaders    : []string{"Content-Length"},
		AllowCredentials : true,
	}))

	r.MaxMultipartMemory = 16 << 20 // 16 MiB

	// ────────────────────────────────────────────────────────────────────────
	//  Public endpoints (no JWT)
	// ────────────────────────────────────────────────────────────────────────
	{
		r.POST("/user/register",         func(c *gin.Context) { handlers.HandleUserRegister(c, ch) })
		r.POST("/user/login",            func(c *gin.Context) { handlers.HandleUserLogin(c, ch) })
		r.DELETE("/user/delete",         func(c *gin.Context) { handlers.HandleUserDelete(c, ch) })
		r.POST("/user/google-login",     func(c *gin.Context) { handlers.HandleUserGoogleLogin(c, ch) })
		r.PATCH("/user/change-password", func(c *gin.Context) { handlers.HandleUserChangePassword(c, ch) })

		// NEW: purchase credits endpoint
		// front-end does: PATCH /purchase { name, amount }
		r.PATCH("/purchase", func(c *gin.Context) {
			handlers.HandleCreditsPurchased(c, ch)
		})
	}

	// ────────────────────────────────────────────────────────────────────────
	//  Student‐only endpoints
	// ────────────────────────────────────────────────────────────────────────
	std := r.Group("/")
	std.Use(mw.JWTAuthMiddleware())
	std.Use(func(c *gin.Context) {
		if c.GetString("role") != "student" {
			c.JSON(403, gin.H{"error": "Access restricted to students only"})
			c.Abort()
			return
		}
		c.Next()
	})
	{
		std.GET ("/personal/grades",             func(c *gin.Context) { handlers.HandleGetPersonalGrades(c, ch) })
		std.PATCH("/student/reviewRequest",      func(c *gin.Context) { handlers.HandlePostNewRequest(c, ch) })
		std.PATCH("/student/status",             func(c *gin.Context) { handlers.HandleGetRequestStatus(c, ch) })
	}

	// ────────────────────────────────────────────────────────────────────────
	//  Instructor‐only endpoints
	// ────────────────────────────────────────────────────────────────────────
	instr := r.Group("/")
	instr.Use(mw.JWTAuthMiddleware())
	instr.Use(func(c *gin.Context) {
		if c.GetString("role") != "instructor" {
			c.JSON(403, gin.H{"error": "Access restricted to instructors only"})
			c.Abort()
			return
		}
		c.Next()
	})
	{
		instr.POST  ("/upload_init",           func(c *gin.Context) { handlers.UploadExcelInit(c, ch) })
		instr.PATCH ("/postFinalGrades",       func(c *gin.Context) { handlers.UploadExcelFinal(c, ch) })
		instr.PATCH ("/instructor/review-list",func(c *gin.Context) { handlers.HandleGetRequestList(c, ch) })
		instr.PATCH ("/instructor/reply",      func(c *gin.Context) { handlers.HandlePostResponse(c, ch) })
	}

	// ────────────────────────────────────────────────────────────────────────
	//  Shared stats endpoints (all roles)
	// ────────────────────────────────────────────────────────────────────────
	stats := r.Group("/stats")
	stats.Use(mw.JWTAuthMiddleware())
	{
		stats.GET("/available", func(c *gin.Context) { handlers.HandleSubmissionLogs(c, ch) })
		stats.GET("/courses",   func(c *gin.Context) { handlers.HandleSubmissionLogs(c, ch) })
	}

	return r
}

===== orchestrator/internal/types/events.go =====
package types

// Define event payload structs

type InstitutionRegisteredEvent struct {
	InstitutionID string `json:"institutionId"`
	Name          string `json:"name"`
	Domain        string `json:"domain"`
	RegisteredAt  string `json:"registeredAt"`
}

// ... others omitted for brevity

===== orchestrator/pkg/auth/helpers.go =====
package auth

import (
	"github.com/gin-gonic/gin"
)

// AuthInfo contains all user authentication information
type AuthInfo struct {
	UserID    string
	Username  string
	Role      string
	StudentID string
}

// GetAuthInfo extracts all authentication info from gin context
func GetAuthInfo(c *gin.Context) AuthInfo {
	return AuthInfo{
		UserID:    getStringFromContext(c, "user_id"),
		Username:  getStringFromContext(c, "username"),
		Role:      getStringFromContext(c, "role"),
		StudentID: getStringFromContext(c, "student_id"),
	}
}

// GetStudentID returns the student ID if user is a student
func GetStudentID(c *gin.Context) string {
	if getStringFromContext(c, "role") == "student" {
		return getStringFromContext(c, "student_id")
	}
	return ""
}

// IsStudent checks if the current user is a student
func IsStudent(c *gin.Context) bool {
	return getStringFromContext(c, "role") == "student"
}

// RequireStudent middleware that ensures only students can access
func RequireStudent() gin.HandlerFunc {
	return func(c *gin.Context) {
		if !IsStudent(c) {
			c.JSON(403, gin.H{"error": "Access restricted to students only"})
			c.Abort()
			return
		}
		c.Next()
	}
}

// RequireStudentWithID middleware that ensures student has a valid student_id
func RequireStudentWithID() gin.HandlerFunc {
	return func(c *gin.Context) {
		if !IsStudent(c) {
			c.JSON(403, gin.H{"error": "Access restricted to students only"})
			c.Abort()
			return
		}
		if GetStudentID(c) == "" {
			c.JSON(400, gin.H{"error": "Student ID is required"})
			c.Abort()
			return
		}
		c.Next()
	}
}

func getStringFromContext(c *gin.Context, key string) string {
	if value, exists := c.Get(key); exists && value != nil {
		if str, ok := value.(string); ok {
			return str
		}
	}
	return ""
}


Processing directory: registration_service
----------------------------

===== registration_service/dbService/dbService.go =====
package dbService

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/jackc/pgx/v5/pgxpool"
)

var Pool *pgxpool.Pool

func InitDB() {
	user := os.Getenv("DB_USER")
	password := os.Getenv("DB_PASSWORD")
	host := os.Getenv("DB_HOST")
	port := os.Getenv("DB_PORT")
	dbname := os.Getenv("DB_NAME")

	dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		user, password, host, port, dbname)

	var err error
	Pool, err = pgxpool.New(context.Background(), dsn)
	if err != nil {
		log.Fatal("Unable to connect to database:", err)
	}

	if err = Pool.Ping(context.Background()); err != nil {
		log.Fatal("Unable to ping the database:", err)
	}

	log.Println("Connected to PostgreSQL via pgxpool.")
}

func AddInstitution(inst_name, email, director string) (int, error) {
	ctx := context.Background()

	checkQuery := `SELECT name FROM institution WHERE name = $1;`
	var existing string
	err := Pool.QueryRow(ctx, checkQuery, inst_name).Scan(&existing)

	if err != nil && existing == inst_name {
		return 2, fmt.Errorf("institution already exists")
	}

	insertQuery := `INSERT INTO institution (name, email, director) VALUES ($1, $2, $3);`
	_, err = Pool.Exec(ctx, insertQuery, inst_name, email, director)
	if err != nil {
		log.Printf("Failed to insert institution: %v", err)
		return 0, err
	}

	return 1, nil
}

===== registration_service/handlers/HandlerRegister.go =====
// handler.go
package handlers

import (
	"encoding/json"
	"log"
	"registration_service/dbService"

	amqp "github.com/rabbitmq/amqp091-go"
)

// UserRequest mirrors the JSON that comes over the wire
type UserRequest struct {
	Name     string `json:"name"`
	Email    string `json:"email"`
	Director string `json:"director"`
}

// Response is sent back to the orchestrator
type Response struct {
	Status  string `json:"status"`  // "ok", "conflict", "error"
	Message string `json:"message"` // details for humans
	// code    int    `json:"code"`
}

func HandleRegister(d amqp.Delivery, ch *amqp.Channel) {
	var req UserRequest
	var res Response

	// Acknowledge the message no matter what (multiple = false)
	defer d.Ack(false)

	// 1. Parse JSON ---------------------------------------------------------
	if err := json.Unmarshal(d.Body, &req); err != nil {
		res.Status = "error"
		res.Message = "Invalid JSON"
		publishReply(ch, d, res)
		return
	}

	// 2. Business logic -----------------------------------------------------
	code, err := dbService.AddInstitution(req.Name, req.Email, req.Director)
	if err != nil {
		if code == 2 {
			res.Status = "conflict"
			res.Message = "Institution already registered"
		} else {
			res.Status = "error"
			res.Message = "Database error"
		}
		publishReply(ch, d, res)
		return
	}

	// 3. Success ------------------------------------------------------------
	res.Status = "ok"
	res.Message = "Institution registered successfully"
	publishReply(ch, d, res)
	return
}

func publishReply(ch *amqp.Channel, d amqp.Delivery, res Response) {
	if d.ReplyTo == "" {
		// fire-and-forget call; nothing to send back
		return
	}

	body, _ := json.Marshal(res)

	err := ch.Publish(
		"",        // default exchange because we address the queue directly
		d.ReplyTo, // queue the caller named
		false,     // mandatory
		false,     // immediate
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: d.CorrelationId,
			Body:          body,
		},
	)
	if err != nil {
		log.Printf(" [!] Failed to publish reply: %v", err)
	}
}

===== registration_service/main.go =====
// main.go
package main

import (
	"log"
	"os"
	"os/signal"
	"syscall"

	"registration_service/dbService"
	"registration_service/handlers"

	"github.com/joho/godotenv"
	amqp "github.com/rabbitmq/amqp091-go"
)

func failOnErr(err error, msg string) {
	if err != nil {
		log.Fatalf("%s: %v", msg, err)
	}
}

func main() {
	// ----------------------------------------------------------------------
	// 1. Environment & DB init
	// ----------------------------------------------------------------------
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found; relying on system environment variables.")
	}

	dbService.InitDB()

	// ----------------------------------------------------------------------
	// 2. Rabbit MQ connection / channel
	// ----------------------------------------------------------------------
	rmqURL := os.Getenv("RABBITMQ_URL")
	if rmqURL == "" {
		rmqURL = "amqp://guest:guest@localhost:5672/"
	}

	conn, err := amqp.Dial(rmqURL)
	failOnErr(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnErr(err, "Failed to open channel")
	defer ch.Close()

	// ----------------------------------------------------------------------
	// 3. Declare exchange & queue (idempotent; safe if already exist)
	// ----------------------------------------------------------------------
	exchange := "clearSky.events"
	routingKey := "institution.registered"

	err = ch.ExchangeDeclare( //post-office
		exchange, // name
		"direct", // type
		true,     // durable
		false,    // auto-delete
		false,    // internal
		false,    // no-wait
		nil,      // args
	)
	failOnErr(err, "Failed to declare exchange")

	q, err := ch.QueueDeclare(
		routingKey, // queue name == routing key
		true,       // durable
		false,      // delete when unused
		false,      // exclusive
		false,      // no-wait
		nil,        // args
	)
	failOnErr(err, "Failed to declare queue")

	err = ch.QueueBind(
		q.Name,     // queue
		routingKey, // routing key
		exchange,   // exchange
		false,
		nil,
	)
	failOnErr(err, "Failed to bind queue")

	// ----------------------------------------------------------------------
	// 4. QoS & consumer
	// ----------------------------------------------------------------------
	err = ch.Qos(1, 0, false) // one message at a time
	failOnErr(err, "Failed to set QoS")

	msgs, err := ch.Consume(
		q.Name,
		"registration_service", // consumer tag
		false,                  // auto-ack -> false (we ack manually)
		false,                  // exclusive
		false,                  // no-local
		false,                  // no-wait
		nil,                    // args
	)
	failOnErr(err, "Failed to register consumer")

	// ----------------------------------------------------------------------
	// 5. Graceful shutdown handling
	// ----------------------------------------------------------------------
	sigs := make(chan os.Signal, 1)
	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	// ----------------------------------------------------------------------
	// 6. Message loop
	// ----------------------------------------------------------------------

	const workers = 20

	log.Println(" [*] Waiting for registration messages …")
	for i := 0; i < workers; i++ {
		go func(id int) {
			log.Printf("Worker %d is ready!", id)
			for d := range msgs {
				handlers.HandleRegister(d, ch)
			}
		}(i)

	}
	select {
	case <-sigs:
		log.Println("Shutdown requested, exiting …")
		return
	}
}


Processing directory: stats_service
----------------------------


Processing directory: student_request_review_service
----------------------------

===== student_request_review_service/controllers/dataStructs.go =====
package controllers

import "time"

type ReviewRequest struct {
	StudentMessage string `json:"student_message" binding:"required"`
}

type ReviewStruct struct {
	Student_id               string     `json:"student_id"`
	Course_id                string     `json:"course_id"`
	Exam_period              string     `json:"exam_period"`
	Student_message          string     `json:"student_message"`
	Status                   string     `json:"status"`
	Instructor_reply_message *string    `json:"instructor_reply_message"`
	Instructor_action        *string    `json:"instructor_action"`
	Review_created_at        time.Time  `json:"review_created_at"`
	Reviewed_at              *time.Time `json:"reviewed_at"`
}

===== student_request_review_service/controllers/GetReviewStatus.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"student_request_review_service/db"
)

func GetReviewStatus(body map[string]interface{}) (string, error) {

	// input send by orchestrator in json form like:
	//{
	//"body": {
	//  "course_id": "101",
	//  "exam_period": "spring 2025",
	//  "user_id": "42"
	//}

	// get data from json
	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing course_id")
	}

	userID, ok := body["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing user_id")
	}

	examPeriod, ok := body["exam_period"].(string)
	if !ok {
		return "", fmt.Errorf("missing exam_period")
	}

	// search db using student_id & course_id & exam_period.
	query := `
		SELECT student_id, course_id, exam_period, student_message, status, instructor_reply_message, instructor_action, review_created_at, reviewed_at 
		FROM reviews 
		WHERE student_id = $1 AND course_id = $2 AND exam_period = $3`

	row := db.DB.QueryRow(query, userID, courseID, examPeriod)

	var review ReviewStruct
	err := row.Scan(
		&review.Student_id,
		&review.Course_id,
		&review.Exam_period,
		&review.Student_message,
		&review.Status,
		&review.Instructor_reply_message,
		&review.Instructor_action,
		&review.Review_created_at,
		&review.Reviewed_at,
	)
	if err != nil {
		emptyResponse := map[string]interface{}{
			"message": "No review found for the given input.",
		}
		respBytes, _ := json.Marshal(emptyResponse)
		return string(respBytes), nil
	}

	resBytes, _ := json.Marshal(review)
	return string(resBytes), nil
}

// FIRST IMPLEMENTATION

/* func GetReviewStatus(c *gin.Context) {
	reviewIDStr := c.Param("review_id")
	reviewID, err := strconv.Atoi(reviewIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid review ID"})
		return
	}
	query := `SELECT student_id, course_id, student_message, status, instructor_reply_message, review_created_at, reviewed_at FROM reviews WHERE review_id = $1`
	row := db.DB.QueryRow(query, reviewID)

	var review ReviewStruct

	err = row.Scan(
		&review.Student_id,
		&review.Course_id,
		&review.Student_message,
		&review.Status,
		&review.Instructor_reply_message,
		&review.Review_created_at,
		&review.Reviewed_at,
	)
	log.Println("Scan error:", err)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Review not found"})
		return
	}

	c.JSON(http.StatusOK, review)

} */

===== student_request_review_service/controllers/PostNewReviewRequest.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"student_request_review_service/db"
)

func PostNewReviewRequest(body map[string]interface{}) (string, error) {
	// input send by orchestrator in json form like:
	// {
	//   "body": {
	//     "exam_period": "spring 2025",
	//     "course_id": "101",
	//     "user_id": 42,
	//     "student_message": "Please recheck my assignment."
	//   }
	// }

	// extract data from input.
	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid course_id")
	}

	examPeriod, ok := body["exam_period"].(string)
	if !ok {
		return "", fmt.Errorf("missing exam_period")
	}

	userID, ok := body["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid user_id")
	}

	studentMessage, ok := body["student_message"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid student_message")
	}

	// add review to db
	query := `INSERT INTO reviews (student_id, course_id, exam_period, student_message) VALUES ($1, $2, $3, $4)`
	result, err := db.DB.Exec(query, userID, courseID, examPeriod, studentMessage)
	if err != nil {
		fmt.Println("Insert error:", err)
		return "", fmt.Errorf("failed to insert review")
	}
	rowsAffected, err := result.RowsAffected()
	if err != nil || rowsAffected == 0 {
		failResponse := map[string]interface{}{
			"error":   "Insert failed",
			"message": "Failed to insert review on student end.",
		}
		failRespBytes, _ := json.Marshal(failResponse)
		return string(failRespBytes), nil
	}

	// Return success response
	response := map[string]interface{}{
		"message": "Review request submitted successfully on student end.",
	}
	respBytes, _ := json.Marshal(response)
	return string(respBytes), nil
}

// FIRST IMPLEMENTATION.

/* func PostNewReviewRequest(c *gin.Context) {
	courseIDStr := c.Param("course_id")
	courseID, err := strconv.Atoi(courseIDStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid course ID"})
		return
	}

	var reqBody ReviewRequest
	if err := c.ShouldBindJSON(&reqBody); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON body"})
		return
	}

	query := `INSERT INTO reviews (student_id, course_id, student_message) VALUES ($1, $2, $3)`
	_, err = db.DB.Exec(query, userID, courseID, reqBody.StudentMessage)
	if err != nil {
		log.Println("Insert error:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to insert review"})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"message":         "Review request submitted successfully.",
		"user_id":         userID,
		"course_id":       courseID,
		"student_message": reqBody.StudentMessage,
	})
} */

===== student_request_review_service/controllers/UpdateInstructorResponse.go =====
package controllers

import (
	"encoding/json"
	"fmt"
	"student_request_review_service/db"
)

func UpdateInstructorResponse(body map[string]interface{}) (string, error) {
	// input send by orchestrator in json form like:
	//{
	//	"body": {
	//	  "course_id": "101",
	//	  "exam_period": "spring 2025",
	//	  "user_id": `031200000`
	//	  "instructor_reply_message": "NO WAY!"
	//	  "instructor_action": "Denied"
	//	}
	//}

	// get data from json
	courseID, ok := body["course_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing course_id")
	}

	userID, ok := body["user_id"].(string)
	if !ok {
		return "", fmt.Errorf("missing user_id")
	}

	examPeriod, ok := body["exam_period"].(string)
	if !ok {
		return "", fmt.Errorf("missing exam_period")
	}

	instructorReply, ok := body["instructor_reply_message"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid instructor_reply_message")
	}

	instructorAction, ok := body["instructor_action"].(string)
	if !ok {
		return "", fmt.Errorf("missing or invalid instructor_action")
	}

	query := `
		UPDATE reviews 
		SET instructor_reply_message = $1,
			instructor_action = $2,
			status = 'reviewed',
			reviewed_at = CURRENT_TIMESTAMP
		WHERE student_id = $3 AND course_id = $4 AND exam_period = $5	
	`

	result, err := db.DB.Exec(query, instructorReply, instructorAction, userID, courseID, examPeriod)
	if err != nil {
		return "", fmt.Errorf("failed to update review: %v", err)
	}

	rowsAffected, _ := result.RowsAffected()
	if rowsAffected == 0 {
		failResponse := map[string]interface{}{
			"message": "Failed to update instructor response in database on student end.",
		}
		failRespBytes, _ := json.Marshal(failResponse)
		return string(failRespBytes), nil
	}

	response := map[string]interface{}{
		"message": "Instructor response updated successfully on student end.",
	}
	respBytes, _ := json.Marshal(response)
	return string(respBytes), nil
}

===== student_request_review_service/db/db_init.go =====
package db

import (
	"database/sql"
	"fmt"

	_ "github.com/lib/pq"
)

var DB *sql.DB

func InitDB() error {

	// CONNECT TO REVIEWS DB
	// URL for docker connection
	//reviewsdbURL := "postgres://postgres:root@db:5432/reviewsdb?sslmode=disable"
	reviewsdbURL := "postgres://postgres:root@student_db:5432/reviewsdb?sslmode=disable"
	// URL for local connection
	// reviewsdbURL := "postgres://postgres:root@localhost:5432/reviewsdb?sslmode=disable"

	var err error
	DB, err = sql.Open("postgres", reviewsdbURL)
	if err != nil {
		fmt.Println("DB open error:", err)
		return err
	}
	err = DB.Ping()
	if err != nil {
		fmt.Println("DB ping error:", err)
		return err
	}
	fmt.Println("DB connection established.")
	return nil
}

func CloseDB() {
	DB.Close()
}

===== student_request_review_service/main.go =====
// student_request_review_service
package main

import (
	"fmt"
	"student_request_review_service/db"
	"student_request_review_service/mq"
	"time"

	_ "github.com/lib/pq"
)

func main() {

	for i := 0; i < 15; i++ {
		err := mq.InitRabbitMQ()
		if err == nil {
			break
		}
		fmt.Printf("Waiting for RabbitMQ... (%d/15)\n", i+1)
		time.Sleep(3 * time.Second)
		if i == 14 {
			panic("Could not connect to RabbitMQ after 15 tries")
		}
	}
	defer mq.Mqconn.Close()
	defer mq.Mqch.Close()

	for i := 0; i < 5; i++ {
		err := db.InitDB()
		if err == nil {
			break
		}
		fmt.Printf("Waiting for DB... (%d/5)\n", i+1)
		time.Sleep(3 * time.Second)
		if i == 4 {
			panic("Could not connect to DB after 5 tries")
		}
	}
	defer db.CloseDB()

	mq.StartConsumer()

	fmt.Println("Student Service started and waiting for RabbitMQ messages...")
	select {}
}

===== student_request_review_service/mq/consumer.go =====
package mq

import (
	"fmt"

	"student_request_review_service/routes"

	"github.com/streadway/amqp"
)

// function to handle errors
func errorHandling(err error, msg string) {
	if err != nil {
		fmt.Printf("%s: %s\n", msg, err)
	}
}

func StartConsumer() {

	// keys for student events
	exchangeKey := "clearSky.events"
	routingKeysStudent := []string{
		"student.postNewRequest",
		"student.getRequestStatus",
		"student.updateInstructorResponse",
	}

	// declare direct exchange for event routing
	err := Mqch.ExchangeDeclare(
		exchangeKey, // name
		"direct",    // type
		true,        // durable
		false,       // auto-deleted
		false,       // internal
		false,       // no-wait
		nil,         // arguments
	)
	errorHandling(err, "Failed to declare exchange")

	// declare a durable queue
	queue, err := Mqch.QueueDeclare(
		"student_queue", // queue name
		true,            // durable
		false,           // delete when unused
		false,           // not exclusive
		false,           // no-wait
		nil,
	)
	errorHandling(err, "Failed to declare queue")

	// bind the queue to each routing key
	for _, key := range routingKeysStudent {
		err := Mqch.QueueBind(
			queue.Name,
			key,
			exchangeKey,
			false,
			nil,
		)
		errorHandling(err, "Failed to bind queue with key "+key)
	}

	// start consuming messages
	msgs, err := Mqch.Consume(
		queue.Name,
		"student_consumer", // consumer tag
		false,              // manual acks!
		false,              // not exclusive
		false,              // no-local (not supported)
		false,              // no-wait
		nil,
	)
	errorHandling(err, "Failed to register consumer")

	fmt.Println("Consumer Declared.")
	fmt.Printf(" [*] Waiting for messages on: %s\n", queue.Name)

	go func() {
		for d := range msgs {
			fmt.Printf("Received message: %s", d.Body)

			response, err := routes.Routing(d.RoutingKey, d.Body)
			if err != nil {
				fmt.Printf("Error processing message for routing key %s: %v", d.RoutingKey, err)
				response = fmt.Sprintf(`{"error": "%s"}`, err.Error())
			}

			fmt.Printf("Reply: %s\n", response)

			err = Mqch.Publish(
				"",        // default exchange for reply
				d.ReplyTo, // reply queue
				false,
				false,
				amqp.Publishing{
					ContentType:   "application/json",
					CorrelationId: d.CorrelationId,
					Body:          []byte(response),
				},
			)

			if err != nil {
				fmt.Println("Reply failed.")
				fmt.Println(err)
				d.Nack(false, true) // requeue on publish failure
			} else {
				fmt.Printf("Sent reply to %s\n", d.ReplyTo)
				d.Ack(false)
			}
		}
	}()
}

// FIRST IMPLEMENTATION

/*
	q := "grades.review.requested"

	// Declare queue if not exists.
	_, err := Mqch.QueueDeclare(
		q,
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		fmt.Println("Queue declaration failed.")
		fmt.Println(err)

	}
	fmt.Println("Queue declared.")
	fmt.Println(q)

	// Consumer
	msgs, err := Mqch.Consume(
		q,
		"",
		true,
		false,
		false,
		false,
		nil,
	)
	if err != nil {
		fmt.Println("Consumer failed")
		fmt.Println(err)
	}
	fmt.Println("Consumer Declared.")
	fmt.Printf(" [*] Waiting for messages on: %s\n", q)



	go func() {
		for d := range msgs {
			fmt.Printf("Received message: %s", d.Body)

			response, err := routes.Routing(d.Body)
			if err != nil {
				fmt.Println("Error processing message:", err)
				response = fmt.Sprintf(`{"error": "%s"}`, err.Error())
			}
			fmt.Printf("Reply: %s\n", response)

			// Send reply
			err = Mqch.Publish(
				"",
				d.ReplyTo,
				false,
				false,
				amqp.Publishing{
					ContentType:   "application/json",
					CorrelationId: d.CorrelationId,
					Body:          []byte(response),
				},
			)
			if err != nil {
				fmt.Println("Reply failed.")
				fmt.Println(err)
			} else {
				fmt.Printf("Sent reply to %s", d.ReplyTo)
			}
		}
	}()*/

===== student_request_review_service/mq/initmq.go =====
package mq

import (
	"fmt"

	"github.com/streadway/amqp"
)

var Mqconn *amqp.Connection
var Mqch *amqp.Channel

func InitRabbitMQ() error {
	var err error
	// FOR LOCAL TESTING ONLY.
	//Mqconn, err = amqp.Dial("amqp://guest:guest@localhost:5672/")
	Mqconn, err = amqp.Dial("amqp://guest:guest@rabbitmq:5672/")
	if err != nil {
		fmt.Println("Failed to connect to RabbitMQ:", err)
		return err
	}
	fmt.Println("RabbitMQ connection initialized.")

	Mqch, err = Mqconn.Channel()
	if err != nil {
		fmt.Println("Failed to open a channel:", err)
		return err
	}
	fmt.Println("RabbitMQ Channel initialized.")
	return nil
}

===== student_request_review_service/routes/routes.go =====
package routes

/* import (
	"student_request_review_service/controllers"

	"github.com/gin-gonic/gin"
)

func PostNewReviewRequest(router *gin.Engine) {
	router.POST("/new_review_request/:course_id", controllers.PostNewReviewRequest)
}

func GetReviewStatus(router *gin.Engine) {
	router.GET("/review_info/:review_id", controllers.GetReviewStatus)
}
*/

// Routing with Rabbit mq -> takes routing key and calls different controller.

import (
	"encoding/json"
	"fmt"
	"student_request_review_service/controllers"
)

type Message struct {
	Params map[string]string      `json:"params"`
	Body   map[string]interface{} `json:"body"`
}

func Routing(routingKey string, messageBody []byte) (string, error) {
	var msg Message
	err := json.Unmarshal(messageBody, &msg)
	if err != nil {
		return "", fmt.Errorf("failed to parse message: %w", err)
	}

	switch routingKey {
	case "student.postNewRequest":
		return controllers.PostNewReviewRequest(msg.Body)

	case "student.getRequestStatus":
		return controllers.GetReviewStatus(msg.Body)

	case "student.updateInstructorResponse":
		return controllers.UpdateInstructorResponse(msg.Body)

	default:
		return "", fmt.Errorf("unknown routing key: %s", routingKey)
	}
}


Processing directory: user_management_service
----------------------------

===== user_management_service/cmd/server/main.go =====
package main

import (
	"log"
	"os"
	"user_management_service/internal/config"
	"user_management_service/internal/handler"
	"user_management_service/internal/messaging"
	"user_management_service/internal/middleware"

	"github.com/gin-gonic/gin"
)

func main() {
	// 1) Database setup
	db := config.SetupDatabase()
	sqlDB, _ := db.DB()
	defer sqlDB.Close()

	// 2) RabbitMQ init (messaging.Init() δηλώνει exchanges & queues/bindings)
	messaging.Init()
	defer messaging.Conn.Close()
	defer messaging.Channel.Close()

	// 3) Start consumer για auth requests
	//    (δεν χρειάζεται να δίνουμε πια το Channel, το έχει ήδη global)
	messaging.ConsumeAuthQueue(db)

	// 4) HTTP server
	r := gin.Default()
	r.POST("/register", handler.Register(db))
	r.POST("/login", handler.Login(db))
	r.POST("/upsert", handler.UpsertUser(db))

	auth := r.Group("/auth")
	auth.Use(middleware.JWTAuthMiddleware()) // sets user_id, email, role in context
	auth.GET("/validate", handler.Validate())
	auth.GET("/profile", handler.Profile(db))

	port := os.Getenv("PORT")
	if port == "" {
		port = "8082"
	}

	log.Println("🟢 User-Management Service listening on port", port)
	r.Run(":" + port)
}

===== user_management_service/dbService/db.go =====
package user_management_service

import (
	"log"
	"os"

	"github.com/joho/godotenv"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"
)

var DB *gorm.DB

// User represents the user model
type User struct {
	gorm.Model
	Username  string
	Password  string
	Role      string
	StudentID string `gorm:"unique"` // Add StudentID field
}

// InitDB initializes the database connection and performs migrations
func InitDB() {
	loadEnvVariables()
	var err error
	dsn := os.Getenv("DB_DSN")
	DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatalf("failed to connect to database: %v", err)
	}

	// Migrate the schema
	DB.AutoMigrate(&User{})
	seedDefaultUsers()
}

// loadEnvVariables loads environment variables from a .env file
func loadEnvVariables() {
	err := godotenv.Load()
	if err != nil {
		log.Fatalf("Error loading .env file")
	}
}

// seedDefaultUsers ensures default users exist for all roles
func seedDefaultUsers() {
	seedAdminUser()
	seedStudentUser()
	seedInstructorUser()
}

// seedAdminUser ensures a default admin exists
func seedAdminUser() {
	passHash, _ := bcrypt.GenerateFromPassword([]byte("admin"), bcrypt.DefaultCost)
	u := User{Username: "admin", Password: string(passHash), Role: "institution_representative"}
	DB.FirstOrCreate(&u, User{Username: "admin"})
}

// seedStudentUser ensures a default student exists
func seedStudentUser() {
	var existingUser User
	result := DB.Where("username = ?", "student").First(&existingUser)
	if result.Error != nil {
		// User doesn't exist, create it
		passHash, _ := bcrypt.GenerateFromPassword([]byte("1234"), bcrypt.DefaultCost)
		u := User{
			Username:  "student",
			Password:  string(passHash),
			Role:      "student",
			StudentID: "03181121",
		}
		DB.Create(&u)
		log.Println("Created default student user")
	} else {
		log.Println("Student user already exists")
	}
}

// seedInstructorUser ensures a default instructor exists
func seedInstructorUser() {
	var existingUser User
	result := DB.Where("username = ?", "instructor").First(&existingUser)
	if result.Error != nil {
		// User doesn't exist, create it
		passHash, _ := bcrypt.GenerateFromPassword([]byte("1234"), bcrypt.DefaultCost)
		u := User{
			Username: "instructor",
			Password: string(passHash),
			Role:     "instructor",
		}
		DB.Create(&u)
		log.Println("Created default instructor user")
	} else {
		log.Println("Instructor user already exists")
	}
}

===== user_management_service/internal/config/config.go =====
package config

import (
	"os"
	"user_management_service/internal/model"

	"golang.org/x/crypto/bcrypt"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

// SetupDatabase opens the DB, runs migrations, and seeds a default admin user
func SetupDatabase() *gorm.DB {
	// Use auth_service.db as default
	dsn := os.Getenv("DATABASE_DSN")
	if dsn == "" {
		dsn = "auth_service.db"
	}
	db, err := gorm.Open(sqlite.Open(dsn), &gorm.Config{})
	if err != nil {
		panic(err)
	}

	// Migrate the User model
	db.AutoMigrate(&model.User{})

	// Seed default admin user (username: admin / password: admin)
	passHash, _ := bcrypt.GenerateFromPassword([]byte("admin"), bcrypt.DefaultCost)
	admin := model.User{Username: "admin", PasswordHash: string(passHash), Role: "institution_representative"}
	db.FirstOrCreate(&admin, model.User{Username: "admin"})

	return db
}

===== user_management_service/internal/handler/login.go =====
package handler

import (
	"net/http"

	"user_management_service/internal/model"
	jwtutil "user_management_service/pkg/jwt"

	"github.com/gin-gonic/gin"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

type LoginRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

func Login(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		var req LoginRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		var user model.User
		if err := db.Where("username = ?", req.Username).First(&user).Error; err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
			return
		}

		if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
			return
		}

		token, err := jwtutil.GenerateToken(user.ID, user.Username, user.Role, user.StudentID)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
			return
		}

		c.JSON(http.StatusOK, gin.H{
			"token":  token,
			"role":   user.Role, // add role to response
			"userId": user.ID,   // add userId for completeness
		})
	}
}

===== user_management_service/internal/handler/profile.go =====
package handler

import (
	"net/http"
	"user_management_service/internal/model"

	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

func Profile(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetString("user_id")
		var u model.User
		if err := db.First(&u, "id = ?", userID).Error; err != nil {
			c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
			return
		}
		c.JSON(http.StatusOK, gin.H{
			"user_id":    u.ID,
			"role":       u.Role,
			"student_id": u.StudentID,
		})
	}
}

===== user_management_service/internal/handler/register.go =====
package handler

import (
	"net/http"
	"user_management_service/internal/model"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// Struct για το request σώμα
type RegisterRequest struct {
	Username  string `json:"username" binding:"omitempty"`
	Password  string `json:"password" binding:"required,min=6"`
	Role      string `json:"role" binding:"required,oneof=student instructor institution_representative"`
	StudentID string `json:"student_id,omitempty"` // Add student_id field
}

// Handler function
func Register(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		var req RegisterRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		// Validate student_id for student role
		if req.Role == "student" && req.StudentID == "" {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Student ID is required for student registration"})
			return
		}

		// Έλεγχος αν το username υπάρχει ήδη
		var existingUser model.User
		if req.Username != "" && db.Where("username = ?", req.Username).First(&existingUser).Error == nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Username already registered"})
			return
		}

		// Check if student_id already exists (if provided)
		if req.StudentID != "" {
			var existingStudent model.User
			if db.Where("student_id = ?", req.StudentID).First(&existingStudent).Error == nil {
				c.JSON(http.StatusBadRequest, gin.H{"error": "Student ID already registered"})
				return
			}
		}

		// Hashάρισμα του password
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to hash password"})
			return
		}

		// Δημιουργία νέου χρήστη
		user := model.User{
			ID:           uuid.New().String(),
			Username:     req.Username,
			PasswordHash: string(hashedPassword),
			Role:         req.Role,
			StudentID:    req.StudentID, // Set student_id
		}

		if err := db.Create(&user).Error; err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create user"})
			return
		}

		c.JSON(http.StatusCreated, gin.H{"message": "User registered successfully"})
	}
}

===== user_management_service/internal/handler/upsert.go =====
package handler

import (
	"net/http"

	"user_management_service/internal/model"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

type UpsertRequest struct {
	Username  string `json:"username" binding:"required"`
	Role      string `json:"role" binding:"required,oneof=student instructor institution_representative"`
	StudentID string `json:"student_id,omitempty"`
}

func UpsertUser(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		var req UpsertRequest
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
			return
		}

		var u model.User
		if err := db.Where("username = ?", req.Username).First(&u).Error; err != nil {
			// create new
			u = model.User{
				ID:        uuid.NewString(),
				Username:  req.Username,
				Role:      req.Role,
				StudentID: req.StudentID,
			}
			db.Create(&u)
		} else {
			// update role if changed
			if u.Role != req.Role {
				u.Role = req.Role
			}
			// set StudentID once supplied
			if req.StudentID != "" && u.StudentID != req.StudentID {
				u.StudentID = req.StudentID
			}
			db.Save(&u)
		}

		c.JSON(http.StatusOK, gin.H{"user_id": u.ID, "role": u.Role})
	}
}

===== user_management_service/internal/handler/validate.go =====
package handler

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

func Validate() gin.HandlerFunc {
	return func(c *gin.Context) {
		userID := c.GetString("user_id")
		email := c.GetString("email")
		role := c.GetString("role")

		c.JSON(http.StatusOK, gin.H{
			"user_id": userID,
			"email":   email,
			"role":    role,
		})
	}
}

===== user_management_service/internal/messaging/consume.go =====
// file: user_management_service/messaging/consumer.go
package messaging

import (
	"encoding/json"
	"log"
	"user_management_service/internal/model"
	"user_management_service/pkg/jwt"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"

	amqp "github.com/rabbitmq/amqp091-go"
)

type AuthRequest struct {
	Type        string `json:"type"` // "register" ή "login"
	Username    string `json:"username,omitempty"`
	Password    string `json:"password,omitempty"`
	Role        string `json:"role,omitempty"`
	StudentID   string `json:"student_id,omitempty"` // Add student_id field
	OldPassword string `json:"old_password,omitempty"`
	NewPassword string `json:"new_password,omitempty"`
}

type AuthResponse struct {
	Status  string `json:"status"`            // "ok" ή "error"
	Message string `json:"message,omitempty"` // λόγος σφάλματος
	Token   string `json:"token,omitempty"`
	Role    string `json:"role,omitempty"`
	UserID  string `json:"userId,omitempty"`
}

func ConsumeAuthQueue(db *gorm.DB) {
	msgs, err := Channel.Consume(
		"auth.request", "", false, false, false, false, nil,
	)
	if err != nil {
		log.Fatalf("Consume auth.request: %v", err)
	}

	go func() {
		for d := range msgs {
			var req AuthRequest
			if err := json.Unmarshal(d.Body, &req); err != nil {
				log.Println("Invalid auth request:", err)
				d.Nack(false, false)
				continue
			}
			var resp AuthResponse
			// register
			if req.Type == "register" {
				if req.Username == "" {
					resp = AuthResponse{Status: "error", Message: "Username required"}
					goto send
				}

				// Check if student_id is required for student role
				role := req.Role
				if role == "" {
					role = "student"
				}

				if role == "student" && req.StudentID == "" {
					resp = AuthResponse{Status: "error", Message: "Student ID required for student registration"}
					goto send
				}

				var existing model.User
				if err := db.Where("username = ?", req.Username).First(&existing).Error; err == nil {
					resp = AuthResponse{Status: "error", Message: "Username already registered"}
				} else {
					// Check if student_id already exists (if provided)
					if req.StudentID != "" {
						var existingStudent model.User
						if err := db.Where("student_id = ?", req.StudentID).First(&existingStudent).Error; err == nil {
							resp = AuthResponse{Status: "error", Message: "Student ID already registered"}
							goto send
						}
					}

					hash, _ := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
					user := model.User{
						ID:           uuid.NewString(),
						Username:     req.Username,
						PasswordHash: string(hash),
						Role:         role,
						StudentID:    req.StudentID, // Set student_id
					}
					if err := db.Create(&user).Error; err != nil {
						resp = AuthResponse{Status: "error", Message: "Failed to create user"}
					} else {
						resp = AuthResponse{Status: "ok", UserID: user.ID, Role: user.Role}
					}
				}
				// login
			} else if req.Type == "login" {
				log.Println("[AuthConsumer] Received login request for username:", req.Username)
				var user model.User
				if req.Username != "" {
					if err := db.Where("username = ?", req.Username).First(&user).Error; err != nil {
						resp = AuthResponse{Status: "error", Message: "Invalid credentials"}
						goto send
					}
				} else {
					resp = AuthResponse{Status: "error", Message: "Username required"}
					goto send
				}
				if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.Password)); err != nil {
					resp = AuthResponse{Status: "error", Message: "Invalid credentials"}
				} else {
					token, err := jwt.GenerateToken(user.ID, user.Username, user.Role, user.StudentID)
					if err != nil {
						resp = AuthResponse{Status: "error", Message: "Token generation failed"}
					} else {
						resp = AuthResponse{Status: "ok", Token: token, Role: user.Role, UserID: user.ID}
					}
				}
				// change_password
			} else if req.Type == "change_password" {
				var user model.User
				if err := db.Where("username = ?", req.Username).First(&user).Error; err != nil {
					resp = AuthResponse{Status: "error", Message: "Invalid credentials"}
				} else if bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(req.OldPassword)) != nil {
					resp = AuthResponse{Status: "error", Message: "Invalid credentials"}
				} else {
					newHash, _ := bcrypt.GenerateFromPassword([]byte(req.NewPassword), bcrypt.DefaultCost)
					if err := db.Model(&user).Update("password_hash", string(newHash)).Error; err != nil {
						resp = AuthResponse{Status: "error", Message: "Failed to update password"}
					} else {
						resp = AuthResponse{Status: "ok"}
					}
				}
			} else {
				resp = AuthResponse{Status: "error", Message: "Unknown request type"}
			}
		send:
			// send RPC reply
			body, _ := json.Marshal(resp)
			if d.ReplyTo != "" {
				Channel.Publish("", d.ReplyTo, false, false, amqp.Publishing{
					ContentType:   "application/json",
					CorrelationId: d.CorrelationId,
					Body:          body,
				})
			}
			d.Ack(false)
		}
	}()
}

===== user_management_service/internal/messaging/produce.go =====
package messaging

import (
	"encoding/json"
	"log"

	"github.com/rabbitmq/amqp091-go"
)

func SendResponse(ch *amqp091.Channel, queue string, corrID string, resp AuthResponse) {
	body, err := json.Marshal(resp)
	if err != nil {
		log.Println("❌ Failed to marshal response:", err)
		return
	}

	err = ch.Publish(
		"",    // default exchange
		queue, // routing key
		false, // mandatory
		false, // immediate
		amqp091.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			Body:          body,
		},
	)
	if err != nil {
		log.Println("❌ Failed to publish response:", err)
	}
}

===== user_management_service/internal/messaging/rabbit.go =====
// file: user_management_service/messaging/rabbit.go
package messaging

import (
	"encoding/json"
	"log"
	"os"
	"time"

	amqp "github.com/rabbitmq/amqp091-go"
)

var (
	Conn    *amqp.Connection
	Channel *amqp.Channel
)

// Init connects to RabbitMQ, declares exchanges & auth queue+bindings.
func Init() {
	url := os.Getenv("RABBITMQ_URL")
	if url == "" {
		url = "amqp://guest:guest@rabbitmq:5672/"
	}
	var err error
	for i := 0; i < 10; i++ { // Try 10 times
		Conn, err = amqp.Dial(url)
		if err == nil {
			break
		}
		log.Printf("RabbitMQ dial failed: %v (retrying in 3s)", err)
		time.Sleep(3 * time.Second)
	}
	if err != nil {
		log.Fatalf("RabbitMQ dial: %v", err)
	}

	// Initialize Channel after successful connection
	Channel, err = Conn.Channel()
	if err != nil {
		log.Fatalf("RabbitMQ channel: %v", err)
	}

	// 1) Declare the orchestrator.commands exchange for RPC commands
	if err := Channel.ExchangeDeclare(
		"orchestrator.commands", "topic", true, false, false, false, nil,
	); err != nil {
		log.Fatalf("Declare orchestrator.commands: %v", err)
	}

	// 2) Declare the clearSky.events exchange for publishing domain events
	if err := Channel.ExchangeDeclare(
		"clearSky.events", "direct", true, false, false, false, nil,
	); err != nil {
		log.Fatalf("Declare clearSky.events: %v", err)
	}

	// 3) Declare and bind the auth.request queue to orchestrator.commands
	queue := "auth.request"
	if _, err := Channel.QueueDeclare(queue, true, false, false, false, nil); err != nil {
		log.Fatalf("QueueDeclare %s: %v", queue, err)
	}
	for _, key := range []string{"auth.register", "auth.login", "auth.delete", "auth.change_password"} {
		if err := Channel.QueueBind(queue, key, "orchestrator.commands", false, nil); err != nil {
			log.Fatalf("QueueBind %s → %s: %v", queue, key, err)
		}
	}

	// 4) Declare and bind the queue for login/register
	for _, key := range []string{"user.login", "user.register"} {
		if err := Channel.QueueBind(
			queue, key, "clearSky.events", false, nil,
		); err != nil {
			log.Fatalf("QueueBind %s: %v", key, err)
		}
	}
}

// PublishEvent στέλνει ένα event στο clearSky.events με το δοσμένο routingKey
func PublishEvent(routingKey string, payload interface{}) {
	body, err := json.Marshal(payload)
	if err != nil {
		log.Printf("PublishEvent marshal: %v", err)
		return
	}
	err = Channel.Publish(
		"clearSky.events", // exchange (fixed name)
		routingKey,        // routing key
		false, false,
		amqp.Publishing{
			ContentType: "application/json",
			Body:        body,
		},
	)
	if err != nil {
		log.Printf("PublishEvent publish: %v", err)
	}
}

===== user_management_service/internal/middleware/jwt_middleware.go =====
package middleware

import (
	"net/http"
	"strings"

	jwtutil "user_management_service/pkg/jwt"

	"github.com/gin-gonic/gin"
)

func JWTAuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header missing"})
			c.Abort()
			return
		}

		parts := strings.Split(authHeader, " ")
		if len(parts) != 2 || parts[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid Authorization header format"})
			c.Abort()
			return
		}

		tokenStr := parts[1]
		claims, err := jwtutil.ParseToken(tokenStr)
		if err != nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
			c.Abort()
			return
		}

		// Αποθήκευση πληροφοριών στο context
		c.Set("user_id", claims.UserID)
		c.Set("username", claims.Username)
		c.Set("role", claims.Role)
		c.Set("student_id", claims.StudentID) // Add student_id to context

		c.Next()
	}
}

===== user_management_service/internal/model/user.go =====
package model

import "time"

type User struct {
	ID           string `gorm:"primaryKey"`
	Username     string `gorm:"uniqueIndex"`
	PasswordHash string
	Role         string
	StudentID    string // optional school ID for students
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

===== user_management_service/pkg/jwt/token.go =====
package jwt

import (
	"os"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

var jwtKey = []byte(os.Getenv("JWT_SECRET")) // Μπορείς να το φορτώνεις από env

type Claims struct {
	UserID    string `json:"user_id"`
	Username  string `json:"username"`
	Role      string `json:"role"`
	StudentID string `json:"student_id,omitempty"`
	jwt.RegisteredClaims
}

// GenerateToken issues a JWT with username instead of email
func GenerateToken(userID, username, role, studentID string) (string, error) {
	expirationTime := time.Now().Add(24 * time.Hour)

	claims := &Claims{
		UserID:    userID,
		Username:  username,
		Role:      role,
		StudentID: studentID,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expirationTime),
		},
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(jwtKey)
}

func ParseToken(tokenStr string) (*Claims, error) {
	token, err := jwt.ParseWithClaims(tokenStr, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return jwtKey, nil
	})

	if err != nil || !token.Valid {
		return nil, err
	}

	claims, ok := token.Claims.(*Claims)
	if !ok {
		return nil, err
	}

	return claims, nil
}

===== user_management_service/tests/test_send_login.go =====
package main

import (
	"encoding/json"
	"log"

	"github.com/google/uuid"
	"github.com/streadway/amqp"
)

func main() {
	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()

	ch, err := conn.Channel()
	if err != nil {
		log.Fatal(err)
	}
	defer ch.Close()

	loginReq := map[string]string{
		"type":       "register",
		"username":   "student2@example.com",
		"password":   "mypassword123",
		"role":       "student",
		"student_id": "STU2024001", // Add student_id for testing
	}
	body, _ := json.Marshal(loginReq)

	corrID := uuid.New().String()
	replyQueue, _ := ch.QueueDeclare("", false, true, true, false, nil)

	err = ch.Publish(
		"orchestrator.commands", // exchange
		"auth.register",         // <-- change from "auth.login" to "auth.register"
		false,
		false,
		amqp.Publishing{
			ContentType:   "application/json",
			CorrelationId: corrID,
			ReplyTo:       replyQueue.Name,
			Body:          body,
		},
	)
	if err != nil {
		log.Fatal(err)
	}
	msgs, _ := ch.Consume(replyQueue.Name, "", true, true, false, false, nil)
	log.Println("Waiting for response...")
	for d := range msgs {
		log.Printf("Received response: %s", d.Body)
		break
	}
}


Processing directory: View_personal_grades
----------------------------


